[{"contentType":"单选题","content":"在C#中，以下是哪种类型是引用类型？","answer":"C","a":"整型","b":"结构体","c":"委托类型","d":"浮点型"},{"contentType":"单选题","content":"在C#中，一般可以使用委托对象的()方法来调用委托","answer":"B","a":"Delegate()","b":"Invoke()","c":"Translate()","d":"Transaction()"},{"contentType":"单选题","content":"在C#中，以下委托声明正确的是()","answer":"D","a":"public string TranslationDelegate(string s);","b":"public delegate TranslationDelegate(string s);","c":"public event string TranslationDelegate(string s);","d":"public delegate string TranslationDelegate(string s);"},{"contentType":"单选题","content":"C#中关于委托,下列说法错误的是()","answer":"D","a":"委托属于引用类型","b":"委托用于封装方法的引用","c":"委托可以封装多个方法","d":"委托不必实例化即可被调用"},{"contentType":"单选题","content":"C#中关于委托,下列说法正确的是()","answer":"C","a":"委托是一种类的成员","b":"委托必须定义在类中","c":"定义委托需要使用delegate关键字","d":"委托只能调用一个方法"},{"contentType":"单选题","content":"在C#中，使用委托涉及的步骤有(), a:实例化委托   b:定义委托    c:使用委托, 请选择正确的步骤","answer":"B","a":"a-b-c","b":"b-a-c","c":"c-a-b","d":"c-b-a"},{"contentType":"单选题","content":"在C#中，以下说法正确的是()","answer":"A","a":"一个委托在某一时刻可以指向多个方法","b":"一个委托在某一时刻不可以指向多个方法","c":"一个委托在某一时刻只能指向多个方法","d":"一个委托在某一时刻可以指向多个事件"},{"contentType":"单选题","content":"在C#中，关于隐式类型说法正确的是()","answer":"C","a":"隐式类型不能存储对象类型","b":"隐式类型赋值后,可以修改数据类型","c":"隐式类型必须在声明的时候进行初始化","d":"隐式类型可以作为全局变量"},{"contentType":"单选题","content":"在C#中，下列()特性不属于C#3.0新增特性","answer":"C","a":"隐式类型","b":"扩展方法","c":"匿名方法","d":"自动实现的属性"},{"contentType":"单选题","content":"在C#中，关于yield关键字说法错误的是()","answer":"D","a":"yield return向枚举器对象提供值","b":"yield break用于中止迭代","c":"yield return不能置于try-catch块中","d":"yield break不能置于try-catch块中"},{"contentType":"单选题","content":"在C#中，下列关于匿名对象说法正确的是()","answer":"B","a":"匿名对象的属性可读,可写","b":"匿名对象的属性可读,不可写","c":"匿名对象的属性可写,不可读","d":"匿名对象的属性不可写,不可读"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式查询出班级编号为1001的班级的所有同学()","answer":"A","a":"studentList.Where(t => t.ClassCode == \"1001\")","b":"studentList.When(t => t.ClassCode == \"1001\")","c":"studentList.Where(ClassCode => \"1001\")","d":"studentList.When(ClassCode => \"1001\")"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式可以查询出班级成绩在80分以上的人数，下列语法正确的是（）","answer":"A","a":"studentList.Count(t => t.ScoreValue >= 80)","b":"studentList.Count(ScoreValue >= 80)","c":"studentList.GroupBy(t => t.ScoreValue >= 80)","d":"studentList.GroupBy(ScoreValue >= 80)"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式对班级所有成绩求平均分，下列语法正确的是（）","answer":"C","a":"scoreList.Count(t => t.ScoreValue)","b":"scoreList.Count(ScoreValue)","c":"scoreList.Average(t => t.ScoreValue)","d":"scoreList.Average(ScoreValue)"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式查询出班级成绩的最高分，下列语法正确的是（）","answer":"A","a":"studentList.Max(t => t.ScoreValue)","b":"studentList.Max(ScoreValue)","c":"studentList.Sum(t => t.ScoreValue)","d":"studentList.Sum(ScoreValue)"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式对班级所有成绩求和，下列语法正确的是（）","answer":"B","a":"scoreList.Sum(ScoreValue)","b":"scoreList.Sum(t => t.ScoreValue)","c":"scoreList.Count(ScoreValue)","d":"scoreList.Count(t => t.ScoreValue)"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式查找班级学生姓名含有“中”字的学生信息，下列语法正确的是（）","answer":"B","a":"studentList.FindAll(StudentName.Contains(\"中\"))","b":"studentList.FindAll(t => t.StudentName.Contains(\"中\"))","c":"studentList.Select(StudentName.Contains(\"中\"))","d":"studentList.Select(t => t.StudentName.Contains(\"中\"))"},{"contentType":"单选题","content":"在C#中，使用Lambda表达式获取班级所有学生的姓名,并去除重名，下列语法正确的是（）","answer":"D","a":"studentList.Select(StudentName.Distinct())","b":"studentList.Select(StudentName).Distinct()","c":"studentList.Select(t => t.StudentName.Distinct())","d":"studentList.Select(t => t.StudentName).Distinct()"},{"contentType":"多选题","content":"在C#中，下列说法正确的有()【选两项】","answer":"CD","a":"必须指定用于设置委托可见性的访问修饰符","b":"必须指定关键字distance","c":"必须指定委托的返回类型，无返回值则使用void关键字","d":"必须指定委托名"},{"contentType":"多选题","content":"在C#中，关于隐式类型说法正确的是()【选三项】","answer":"ABD","a":"var类型会被编译器根据初始值的类型推断出具体的类型","b":"var类型的局部变量必须赋予初始值","c":"可以将null赋值给隐式类型的局部变量","d":"var不能用作方法的参数"},{"contentType":"多选题","content":"在C#中，关于匿名对象说法正确的是()【选两项】","answer":"AC","a":"在开发过程中对于使用较少的类型,可以创建匿名对象","b":"匿名对象可以作为类的属性","c":"匿名对象可以使用var声明的变量接收","d":"匿名对象可以通过类名调用"},{"contentType":"多选题","content":"在C#中，关于多播委托描述正确的是()【选三项】","answer":"ABD","a":"包含多个方法的委托叫做多播委托","b":"如果调用多播委托，就可以顺序连续调用多个方法","c":"多播委托中,委托的签名必须返回void","d":"使用多播委托,只能得到委托调用的最后一个方法的结果"},{"contentType":"多选题","content":"在C#中，关于扩展方法的说法正确的是()【选三项】","answer":"ABC","a":"C#扩展方法所在的类必须是静态类","b":"C#扩展方法必须是静态方法","c":"C#扩展方法的第一个参数前必须加this","d":"C#扩展方法的调用与调用类型的静态方法一样，即通过类名调用"},{"contentType":"多选题","content":"在C#中，关于扩展方法的说法正确的是()【选三项】","answer":"ACD","a":"扩展方法不能访问被扩展类的私有成员","b":"扩展方法需要修改原有的类来添加新方法","c":"扩展方法只能使用实例来调用，不能像普通的静态方法一样使用类名调用","d":"只有引入扩展方法所在的命名空间后，扩展方法才可以使用"},{"contentType":"单选题","content":"在C#中，下列哪项查询技术是由微软公司推出的？（）","answer":"C","a":"SQL","b":"XML","c":"LINQ","d":"Xquery"},{"contentType":"多选题","content":"在C#中，下列哪些数据可以使用LINQ来查询？ （）【选三项】","answer":"ABC","a":"XML文档","b":"SQL数据库","c":"ADO.NET数据集","d":"JavaScript"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来指定范围变量和数据源（）","answer":"B","a":"where","b":"from","c":"select","d":"group"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来根据bool表达式从数据源中筛选数据（）","answer":"A","a":"where","b":"from","c":"select","d":"group"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来指定查询结果中的元素所具有的的类型或表现形式（）","answer":"C","a":"where","b":"from","c":"select","d":"group"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来对查询结果按照键/值执行分组（）","answer":"D","a":"where","b":"from","c":"select","d":"group"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来对查询出的元素执行排序（）","answer":"D","a":"where","b":"group","c":"join","d":"orderby"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ关键字用来按照两个指定匹配条件对等连接两个数据源（）","answer":"C","a":"where","b":"group","c":"join","d":"orderby"},{"contentType":"多选题","content":"在C#中，LINQ查询有两种语法可供选择，分别是（）【选两项】","answer":"AB","a":"查询语法","b":"方法语法","c":"SQL语法","d":"HTML语法"},{"contentType":"单选题","content":"在C#的LINQ方法语法中，下列哪个方法的可以对集合中的元素计数（）","answer":"A","a":"Count()","b":"Max()","c":"Min()","d":"Sum()"},{"contentType":"单选题","content":"在C#的LINQ方法语法中，下列哪个方法的可以确定集合中的最大值（）","answer":"B","a":"Count()","b":"Max()","c":"Min()","d":"Sum()"},{"contentType":"单选题","content":"在C#的LINQ方法语法中，下列哪个方法的可以确定集合中的总和（）","answer":"D","a":"Count()","b":"Max()","c":"Min()","d":"Sum()"},{"contentType":"单选题","content":"在C#的LINQ方法语法中，下列哪个方法的可以确定集合中的最小值（）","answer":"C","a":"Count()","b":"Max()","c":"Min()","d":"Sum()"},{"contentType":"单选题","content":"在C#的LINQ方法语法中，下列哪个方法的可以确定集合中的平均值（）","answer":"A","a":"Average()","b":"Max()","c":"Min()","d":"Sum()"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ方法是返回集合中指定索引处的元素（）","answer":"A","a":"Elementat()","b":"First()","c":"Last()","d":"Single()"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ方法是返回集合中 的第一个元素或者满足条件的第一个元素（）","answer":"B","a":"Elementat()","b":"First()","c":"Last()","d":"Single()"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ方法是返回集合中 的最后一个元素或者满足条件的最后一个元素（）","answer":"C","a":"Elementat()","b":"First()","c":"Last()","d":"Single()"},{"contentType":"单选题","content":"在C#中，下列哪个LINQ方法是返回集合中的唯一元素或满足条件的唯一元素（）","answer":"D","a":"Elementat()","b":"First()","c":"Last()","d":"Single()"},{"contentType":"多选题","content":"在C#中，下列哪些LINQ方法是返回集合中的唯一元素或满足条件的唯一元素（）【选两项】","answer":"AD","a":"SingleOrDefault()","b":"First()","c":"FirstOrDefault()","d":"Single()"},{"contentType":"多选题","content":"在C#中，下列哪些LINQ方法是返回集合中 的最后一个元素或者满足条件的最后一个元素（）【选两项】","answer":"AB","a":"LastOrDefault()","b":"Last()","c":"FirstOrDefault()","d":"First()"},{"contentType":"多选题","content":"在C#中，下列哪些LINQ方法是返回集合中 的第一个元素或者满足条件的第一个元素（）【选两项】","answer":"BC","a":"Last()","b":"First()","c":"FirstOrDefault()","d":"LastOrDefault()"},{"contentType":"多选题","content":"在C#中，下列哪些LINQ方法是返回集合中指定索引处的元素（）【选两项】","answer":"AB","a":"Elementat()","b":"ElementatOrDefault()","c":"Single()","d":"SingleOrDefault()"},{"contentType":"单选题","content":"在C#中，下列的哪个LINQ方法可以将集合转化为List<T>（）","answer":"A","a":"ToList()","b":"ToArray()","c":"ToDictionary()","d":"ToLookup()"},{"contentType":"单选题","content":"在C#中，下列的哪个LINQ方法可以将集合转化为数组（）","answer":"B","a":"ToList()","b":"ToArray()","c":"ToDictionary()","d":"ToLookup()"},{"contentType":"单选题","content":"在C#中，下列的哪个LINQ方法可以根据指定的类型进行筛选？（     ）","answer":"A","a":"OfType()","b":"Cast()","c":"AsQueryable()","d":"AsEnumeralbe()"},{"contentType":"单选题","content":"在C#中，下列的哪个LINQ方法可以将集合的元素强制转换为指定类型（）","answer":"B","a":"OfType()","b":"Cast()","c":"AsQueryable()","d":"AsEnumeralbe()"},{"contentType":"单选题","content":"在C#中，下列的哪个LINQ方法可以将一个序列转换为IEnumerable<T>集合（）","answer":"D","a":"OfType()","b":"Cast()","c":"AsQueryable()","d":"AsEnumeralbe()"},{"contentType":"单选题","content":"在C#中，微软公司的企业级ORM框架描述正确的是：（）","answer":"B","a":"只支持微软的SQLServer数据库","b":"微软公司的企业级ORM框架称为ADO.NET实体数据库框架","c":"对数据操作程序员需要编写对应的SQL语句","d":"高性能复杂查询的项目中使用表现很好"},{"contentType":"单选题","content":"在C#中，EF建模Database First方式理解说法正确的是（）","answer":"D","a":"创建model，然后根据model自动建立数据库","b":"直接在model里面写实体类和dbcontext上下文类","c":"先创建数据库，程序员编写SQL语句并处理数据与对象的转换","d":"先创建数据库，生成数据模型"},{"contentType":"单选题","content":"在C#中，EF中提交更改保存到数据库的方法是（）","answer":"C","a":"Remove()","b":"Find()","c":"SaveChanges()","d":"Submit()"},{"contentType":"单选题","content":"在C#中，VisualStudio EF模型设计器为数据库创建模型，在项目中生成EF设计器文件扩展名为（）","answer":"A","a":".edmx","b":".config","c":".cs","d":".html"},{"contentType":"单选题","content":"在C#中，对于没有主键的表，EF对其映射实体描述正确的是（）","answer":"D","a":"数据库表不能没有主键","b":"没有主键的表，EF框架才能生成实体类","c":"表数据库表有或者没有主键，不影响EF框架将其生成实体类","d":"没有主键的表，EF框架生成实体类时会失败"},{"contentType":"单选题","content":"在C#中，补充代码，实现添加数据的效果\nContact contact = new Contact();\ncontact.Name = \"张三\";\ncontact.EnrollmentDate = DateTime.Now;\ndbContext.Contacts._________;\ndbContext.SaveChanges();","answer":"B","a":"Insert(contact)","b":"Add(contact)","c":"Plus(contact)","d":"Append(contact)"},{"contentType":"多选题","content":"在C#中，在EF中下列哪些方法不能支持删除操作是：（）【选三项】","answer":"ABD","a":"Cut","b":"Delete","c":"Remove","d":"drop"},{"contentType":"单选题","content":"在C#中，ORM框架其中模型类对应为：（）","answer":"A","a":"数据表","b":"字段","c":"字段约束","d":"表记录"},{"contentType":"多选题","content":"在C#中，关于ORM技术优点说法正确的是：（）【选三项】","answer":"ACD","a":"提升了开发效率,不需要编写Sql脚本","b":"运行效率比Sql脚本高","c":"跨数据库支持能力强大,只需修改配置就可以轻松实现数据库切换","d":"提供友好的可视化模型设计器"},{"contentType":"单选题","content":"在C#中，ORM的具体含义中\"O\"的具体含义是：（）","answer":"B","a":"O对应程序中的类。","b":"O对应程序中的对象。","c":"O对应关系模型中的关系。","d":"O表示程序中对象和关系模型中关系之间的映射。"},{"contentType":"单选题","content":"在C#中，ORM的具体含义中\"R\"的具体含义是：（）","answer":"C","a":"R对应程序中的类。","b":"R对应程序中的对象。","c":"R对应关系模型中的关系。","d":"R表示程序中对象和关系模型中关系之间的映射。"},{"contentType":"单选题","content":"在C#中，ORM的具体含义中\"M\"的具体含义是：（）","answer":"D","a":"M对应程序中的类。","b":"M对应程序中的对象。","c":"M对应关系模型中的关系。","d":"M表示程序中对象和关系模型中关系之间的映射。"},{"contentType":"单选题","content":"在C#中，使用Database First模式建模，下列操作顺序正确的是：（）\n1、添加“ADO.NET实体数据模型”。\n2、创建数据库连接。\n3、选择“来自数据库的EF设计器”。\n4、选择“实体框架6.X”。\n5、选择数据表。\n6、点击“完成”，VisualStudio创建出数据模型关系图。","answer":"B","a":"1、2、3、4、5、6","b":"1、3、2、4、5、6","c":"1、2、3、5、4、6","d":"1、3、2、5、4、6"},{"contentType":"多选题","content":"在C#中，EF支持哪些模式的数据建模：（）【选三项】","answer":"ACD","a":"Database First","b":"Sql First","c":"Model First","d":"Code First"},{"contentType":"多选题","content":"在C#中，下列关于EF框架的特点说法正确的是（）：【选三项】","answer":"ABD","a":"支持多种数据库","b":"映射引擎支持存储过程","c":"通过SQLHelper类实现对数据库的操作","d":"提供Visual Studio基础工具，执行可视化操作"},{"contentType":"单选题","content":"在C#中，“数据库上下文类”的主要作用说法正确的是（）","answer":"C","a":"“数据库上下文类”主要用于自动生成SQL脚本","b":"“数据库上下文类”主要用于生成数据库的映射类","c":"“数据库上下文类”主要用于追踪和识别业务实体对象的变更，是数据库访问操作的入口。","d":"“数据库上下文类”主要用于ORM的可视化配置"},{"contentType":"单选题","content":"在C#中，使用EF框架需要导入的命名空间是（）","answer":"B","a":"System.Entity","b":"System.Data.Entity","c":"System.Data.EntityFramework","d":"System.EntityFramework"},{"contentType":"单选题","content":"在C#中，ORM全称是（）","answer":"A","a":"对象-关系映射","b":"实体数据模型","c":"免费、开源托管的计算机软件框架","d":".net Framework4.0中推出的语言基础查询"},{"contentType":"单选题","content":"在C#中，数据中结构有变化时候，应选择下列哪种操作同步模型（）","answer":"D","a":"EF设计器的空白处使用鼠标 右键，选择“添加代码生成项”","b":"EF设计器的空白处使用鼠标 右键，选择“根据模型生成数据库”","c":"EF设计器的空白处使用鼠标 右键，选择“验证”","d":"EF设计器的空白处使用鼠标 右键，选择“从数据库更新模 型”"},{"contentType":"单选题","content":"在C#中，使用EF向“Meixin数据库”的Admin数据表添加一条管理员信息：管理员对象已经初始化“admin”。\n代码可以如何编写：（）","answer":"C","a":"meixinEntities db = new meixinEntities();\ndb.SaveChanges();\ndb.Admin.Add(admin);","b":"using(meixinEntities db = new meixinEntities())\n        {\ndb.SaveChanges();\ndb.Admin.Add(admin);\n        }","c":"using(meixinEntities db = new meixinEntities())\n        {\n            db.Admin.Add(admin);\n            db.SaveChanges();\n        }","d":"meixinEntities.Admin.Add(admin);\nmeixinEntities.SaveChanges();"},{"contentType":"单选题","content":"在C#中，使用EF将制定的用户信息从数据库中删除Id为1的数据\n代码可以如何编写：（）","answer":"A","a":"using(meixinEntities db = new meixinEntities())\n        {\n            var user = db.User.FirstOrDefault(p => p.Id == 1);\n            db.User.Remove(user);\n            db.SaveChanges();\n        }","b":"using(meixinEntities db = new meixinEntities())\n        {\n            var user = db.User.FirstOrDefault(p => p.Id == 1);\n            db.User.Remove(user);\n        }","c":"meixinEntities db = new meixinEntities();\n            var user = db.User.FirstOrDefault(p => p.Id == 1);\n            db.SaveChanges();","d":"meixinEntities db = new meixinEntities();\n            var user = db.User.FirstOrDefault(p => p.Id == 1);\n            db.User.Remove(user);"},{"contentType":"单选题","content":"在C#中，ORM框架 类中属性对应关系表的（）","answer":"B","a":"数据表","b":"字段","c":"字段约束","d":"表记录"},{"contentType":"单选题","content":"在C#中，ORM框架其中类的导航属性对应关系表的（）：","answer":"C","a":"数据表","b":"字段","c":"主外键约束","d":"表记录"},{"contentType":"单选题","content":"在C#中，ORM框架其中模型类的实例对应关系表中的（）","answer":"D","a":"数据表","b":"字段","c":"字段约束","d":"表记录"},{"contentType":"单选题","content":"在C#中，VisualStudio EF模型设计器为数据库创建模型时生成的映射文件属于什么文件（）","answer":"A","a":"XML文件","b":"cs原文件","c":"resx资源文件","d":"config文件"},{"contentType":"单选题","content":"在C#中，关于EF建模CodeFirst方式理解正确的是（）","answer":"A","a":"先在程序中建立要映射到数据库的实体结构，然后EntityFramework可以根据实体结构生成所对应的数据库","b":"应用程序已经拥有相应的数据库，使用EF设计工具由数据库生成数据模型类","c":"先创建数据库，程序员编写SQL语句并处理数据与对象的转换","d":"设计出可视化的实体数据模型及他们之间的关系，然后再根据这些实体、关系去生成数据库对象及相关代码文件"},{"contentType":"多选题","content":"在C#中，适合ORM使用场合有哪些（）【选三项】","answer":"BCD","a":"有复杂的查询","b":"对性能要求不是很苛刻的程序","c":"开发时间紧迫时","d":"有数据库迁移需求时"},{"contentType":"多选题","content":"在C#中，在数据上下文中DbContext中有一个Database属性,Database属性中有两组方法，即(    )和(    )【选两项】","answer":"BD","a":"ExecuteCommand","b":"ExecuteSqlCommand","c":"SqlQuery","d":"ExecuteQuery"},{"contentType":"多选题","content":"在C#中，EF中的主从表查询方式有(    )【选三项】","answer":"ABC","a":"显式加载","b":"贪婪加载","c":"延迟加载","d":"立即加载"},{"contentType":"多选题","content":"在C#中，以下关于延迟加载,说法错误的是(    )【选三项】","answer":"BCD","a":"只在需要的时侯加载数据，当对象使用时，再去数据库中加载","b":"一次性组织好数据，并加载到内存。当实体加载时，相关联的数据也一同被加载","c":"除非需要在代码中显示获取数据，在访问导航属性时，不会出现自动加载","d":"以上说法都不正确"},{"contentType":"多选题","content":"在C#中，以下关于贪婪加载,说法错误的是(    )【选三项】","answer":"ACD","a":"只在需要的时侯加载数据，当对象使用时，再去数据库中加载","b":"一次性组织好数据，并加载到内存。当实体加载时，相关联的数据也一同被加载","c":"除非需要在代码中显示获取数据，在访问导航属性时，不会出现自动加载","d":"以上说法都不正确"},{"contentType":"多选题","content":"在C#中，以下关于显式加载,说法错误的是(    )【选三项】","answer":"ABD","a":"只在需要的时侯加载数据，当对象使用时，再去数据库中加载","b":"一次性组织好数据，并加载到内存。当实体加载时，相关联的数据也一同被加载","c":"除非需要在代码中显示获取数据，在访问导航属性时，不会出现自动加载","d":"以上说法都不正确"},{"contentType":"多选题","content":"在C#中，EF默认支持延迟加载，有两种方法可以关闭延迟加载，分别是（）和(  )？【选两项】","answer":"AC","a":"对于特定的导航属性，在定义属性时取消virtual","b":"手动加载关联的数据，通过访问对象状态管理器来获取实体，调用Collection.Load方法获取集合，或调用持有单个实体的属性的Reference.Load方法","c":"对于所有的导航属性在数据上下文类的构造函数中设置LazyLoadingEnabled为false","d":"在查询主表时使用include方法同时查询子表"},{"contentType":"单选题","content":"在C#中，使用ExecuteSqlCommand()方法执行DDL语句(create、alter、drop等)返回值是(      )","answer":"A","a":"-1","b":"1","c":"0","d":"受影响的行数"},{"contentType":"单选题","content":"在C#中，使用ExecuteSqlCommand()方法执行DML(insert、update、delete)返回值是(        )。","answer":"D","a":"-1","b":"1","c":"0","d":"受影响的行数"},{"contentType":"单选题","content":"在C#中，SqlQuery()是用来执行查询,SqlQuery()使用前需要指定返回值的类型。返回值类型可以是定义的(    )，或者基元类型","answer":"C","a":"基础数据类型","b":"引用类型","c":"实体类型","d":"任意类型"},{"contentType":"单选题","content":"在C#中，SqlQuery()查询一个用户的完整信息，返回类型就是用户(    )类型；如果是统计有多少个用户，返回值就是(    )类型","answer":"B","a":"实体,void","b":"实体,int","c":"实体,float","d":"实体,double"}]