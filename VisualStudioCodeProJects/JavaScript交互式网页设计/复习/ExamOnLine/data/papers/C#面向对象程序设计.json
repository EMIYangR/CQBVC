[{"contentType":"单选题","content":"对于下列代码的出错原因,描述正确的是( )\nclass Program\n    {\n        static void Main(string[] args)\n        {\n\t\t    //创建Appliance对象时报错\n            Appliance apl = new Appliance();\n            Appliance mlp = new MobilePhone();\n        }\n    }\n\n    abstract class Appliance\n    {\n        public abstract void Charge();\n    }\n\t\n    class MobilePhone : Appliance\n    {\n        public void Call()\n        {\n            Console.WriteLine(\"手机可以打电话。\");\n        }\n\n        public override void Charge()\n        {\n            Console.WriteLine(\"手机使用110V电压充电。\");\n        }\n    }","answer":"B","a":"Appliance类在实例化的时候书写的位置不正确，导致报错。","b":"Appliance是一个抽象类，不允许直接实例化,只能够实例化非抽象的子类MobilePhone。","c":"定义Appliance类的时候在Charge方法中没有任何方法体，所以创建其对象没有任何意义，所以系统报出错误。","d":"代码关系没有理解错误，应该写为:MobilePhone pm = new Appliance()。"},{"contentType":"单选题","content":"    下列代码报错的原因是（）\n public interface IAnimal \n    {\n\t    //Eat方法报错\n        void Eat() \n        {\n            Console.WriteLine(\"动物需要吃饭。\");\n        }\n    }","answer":"C","a":"study()方法没有加访问修饰符public,导致报错。","b":"接口IStudent没有添加修饰符public,导致报错。","c":"Study()方法是属于接口IStudent的成员方法，不能够有具体实现。导致报错。","d":"方法体输出语句有问题，导致报错。"},{"contentType":"单选题","content":"（）在属性的set 块实现内，用于访问传递给该属性的内置参数。","answer":"B","a":" This ","b":"Value","c":"Args","d":"property"},{"contentType":"单选题","content":"ArrayList中存储的元素超出容量时，会出现下列哪种状态（）","answer":"D","a":"其容量变为之前的一半","b":"程序会报错","c":"其容量不变","d":"其容量自动增长一倍"},{"contentType":"单选题","content":"A类被B类继承，B类被C类继承，那么C类具有了A类的特征，这表现了类的（）","answer":"B","a":"封装性","b":"传递性","c":"单根性","d":"规律性"},{"contentType":"多选题","content":"c#程序中使用继承的优点有哪些（）","answer":"ABC","a":"提高部分模块代码的复用性","b":"提高部分模块代码的扩展性","c":"提高软件的开发效率","d":"提高代码的运行速度"},{"contentType":"单选题","content":"C# 类中内部成员，不包括（）","answer":"D","a":"方法","b":"字段","c":"属性","d":"抽象"},{"contentType":"单选题","content":"C# 中的集合被定义在（）命名空间中。","answer":"C","a":"System.Collections.Generic","b":"System.IO","c":"System.Collections","d":"System.Reflection"},{"contentType":"多选题","content":"C# 中的集合的特点有下列哪些（）","answer":"ABC","a":"动态的改变大小","b":"可存储任意类型的对象","c":"提供一系列操作集合中对象的方法","d":"有固定的大小"},{"contentType":"单选题","content":"C#面向对象中，例如：客户去银行取现金，不可能直接从保险柜中随意拿取现金，只能通过ATM或业务办理窗口取出存在银行的现金，那么现金就就可以看作银行对象的（），ATM机业务办理窗口看作（），即可体现面向对象中封装的特性。","answer":"B","a":"属性；字段","b":"字段；属性","c":"字段；方法","d":"属性；方法"},{"contentType":"多选题","content":"C#中的多态可以通过（）实现","answer":"BCD","a":"密封类","b":"方法重载","c":"抽象类","d":"虚方法"},{"contentType":"单选题","content":"C#中的方法重载主要包括参数不同类型的重载和参数数量不同的重载，下列选项中的两\n个方法不属于重载方法的是（ ）","answer":"B","a":"public int Hello(int int1){// 省略方法体}\npublic int Hello(String str1){// 省略方法体}","b":"public int Hello(){// 省略方法体}\npublic String Hello(){// 省略方法体}","c":"public int Hello(){// 省略方法体}\npublic int Hello (String str1){// 省略方法体}","d":"public String Hello(String str1, String str2){// 省略方法体}\npublic String Hello(String str){// 省略方法体}"},{"contentType":"单选题","content":"C#中的属性主要体现了面向对象编程的（）特性。","answer":"A","a":"封装","b":"继承","c":"多态","d":"抽象"},{"contentType":"单选题","content":"C#中若要某方法只能在当前类或当前类的派生类中访问，可以使用（）访问修饰符","answer":"C","a":"public","b":"private","c":"protected","d":"internal"},{"contentType":"单选题","content":"C#中若要某方法只能在当前类中访问，可以使用（）访问修饰符","answer":"B","a":"public","b":"private","c":"protected","d":"internal"},{"contentType":"单选题","content":"C#中使用(  )关键字定义接口。","answer":"A","a":"interface","b":"abstruct","c":"struct","d":"virtual"},{"contentType":"单选题","content":"C#中使用overried重写父类的同名方法，可以体现出面向对象编程的（）特性。","answer":"C","a":"封装","b":"继承","c":"多态","d":"抽象"},{"contentType":"单选题","content":"C#中下列代码运行结果是（）\npublic abstract class A\n    {\n        public A()\n        {\n            Console.Write(\"A\");\n        }\n        public virtual void Fun()\n        {\n            Console.WriteLine(\"C\");\n        }\n    }\n    public class B : A\n    {\n        public B()\n        {\n            Console.Write(\"B\");\n        }\n        public new void Fun()\n        {\n            Console.WriteLine(\"D\");\n        }\n    }\n    class Program\n    {\n       \n        static void Main(string[] args)\n        {\n            A a = new B();\n        }\n    }","answer":"C","a":"ABCD","b":"BDAC","c":"AB","d":"BA"},{"contentType":"单选题","content":"C#中下列代码运行结果是（）\npublic class Student\n    {\n        public virtual void Exam()\n        {\n            Console.WriteLine(\"学生都要考试\");\n        }\n    }\n    public class Undergraduate : Student\n    {\n        public new void Exam()\n        {\n            Console.WriteLine(\"大学生有选择考试科目的权利\");\n        }\n    }\nclass Program\n    {\n        static void Main(string[] args)\n        {\n            Student stu = new Undergraduate();\n            stu.Exam();\n        }\n    }","answer":"A","a":"学生都要考试","b":"大学生有选择考试科目的权利","c":"学生都要考试    \n大学生有选择考试科目的权利","d":"学生都要考试\n学生都要考试"},{"contentType":"多选题","content":"foreach 循环在处理集合和数组相对于 for 循环的优势有哪些（）","answer":"ABCD","a":"语句简洁","b":"效率更加高","c":"不需要知道循环次数","d":"不用关心数组的起始索引"},{"contentType":"单选题","content":"FileMode 的枚举值Create描述正确的是（）","answer":"B","a":"创建新文件，如果文件已存在，则引发异常","b":"创建新文件，如果文件已存在，则覆盖","c":"打开文件，如果文件不存在，则引发异常","d":"打开文件，如果文件不存在，则创建新文件"},{"contentType":"单选题","content":"Hashtable的常用方法不包括（）","answer":"D","a":"Add","b":"Remove","c":"Clear","d":"Insert"},{"contentType":"单选题","content":"OpenFileDialog 的CheckFileExists属性的作用是（）","answer":"A","a":"在用户指定不存在的文件时是否显示警告","b":"对话框的初始目录","c":"文件筛选器，按“显示名称 | 类型”格式编写","d":"在对话框中选择的文件筛选器的索引"},{"contentType":"单选题","content":"OpenFileDialog 的Filter属性设置正确的是（）","answer":"C","a":"文本文件~*.txt","b":"文本文件\\*.txt","c":"文本文件|*.txt","d":"文本文件&*.txt"},{"contentType":"单选题","content":"OpenFileDialog的DefaultExt可以用来设置（）","answer":"A","a":"默认扩展名","b":"对话框的初始目录","c":"是否自动添加默认扩展名","d":"将显示在对话框标题栏中的字符"},{"contentType":"单选题","content":"OpenFileDialog对话框可以设置初始目录的属性是（）","answer":"A","a":"InitialDirectory","b":"FilterIndex  ","c":"Title  ","d":"AddExtension "},{"contentType":"单选题","content":"OpenFileDialog对话框可以设置对话框中标题栏的文字的属性是（）","answer":"A","a":"Title  ","b":"FilterIndex  ","c":"InitialDirectory","d":"AddExtension "},{"contentType":"单选题","content":"OpenFileDialog用来设置自动添加默认扩展名的属性是（）","answer":"C","a":"CheckPathExists","b":"CheckFileExists","c":"AddExtension","d":"DefaultExt"},{"contentType":"单选题","content":"StreamReader 用于读取一行数据的方法是（）","answer":"A","a":"ReadLine()","b":"Read()","c":"ReadToEnd()","d":"Close()"},{"contentType":"单选题","content":"标记对象可以被序列化的特性是（）","answer":"A","a":"Serializable","b":"Runtime","c":"Formatters","d":"Windows"},{"contentType":"单选题","content":"抽象类中，子类通过关键字(  )实现抽象方法。","answer":"D","a":"abstract","b":"interface   ","c":"virtual   ","d":"override"},{"contentType":"多选题","content":"对文件对话框控件描述正确的是（）","answer":"ABC","a":"OpenFileDialog是打开文件的对话框","b":"SaveFileDialog是保存文件的对话框","c":"FolderBroswerDialog是打开文件夹的对话框","d":"OpenDialog是打开文件的对话框"},{"contentType":"单选题","content":"对于C#程序中的访问修饰符描述正确的是（）","answer":"D","a":"public是完全公开的","b":"private私有的，只能在当前类中进行访问","c":"protected受保护的，只能在当前类或当前类的派生类中访问","d":"以上说法都正确"},{"contentType":"多选题","content":"对于抽象类的规则以下描述正确的是（）","answer":"ABCD","a":"不能创建抽象类的实例","b":"不能在抽象类外定义抽象方法","c":"不能把抽象类声明为sealed","d":"抽象类的抽象成员在派生类中必须全部实现"},{"contentType":"单选题","content":"对于抽象类的意义以下说法正确的是（）","answer":"D","a":"包含公共的属性和行为，被子类所共享–代码重用","b":"为所有子类提供一种统一的类型–向上造型","c":"包含抽象方法，为子类提供一个统一的入口，子类有不同的实现","d":"以上说法全部正确"},{"contentType":"单选题","content":"对于方法重载的特点，描述错误的是（）","answer":"C","a":"方法名称必须相同","b":"方法的参数必须不相同","c":"返回值类型必须相同","d":"可以减轻命名负担"},{"contentType":"单选题","content":"对于方法重载的作用描述错误的是（）","answer":"D","a":"可以减轻命名负担","b":"方便自适应调用","c":"代码更灵活","d":"提高了运行效率"},{"contentType":"单选题","content":"对于构造函数，描述错误的是（）","answer":"D","a":"构造函数名必须与类名相同","b":"构造函数没有返回值类型","c":"构造函数可以没有参数","d":"一个类只能有一个构造函数"},{"contentType":"多选题","content":"对于文件操作的Move() 方法说法错误的是（）","answer":"ABD","a":"可以复制文件","b":"可以检测文件是否存在","c":"移动文件到新的位置","d":"不能移动文件的位置"},{"contentType":"单选题","content":"对于下列代码的出错描述正确的是（）\n\n\nabstract class Cat\n    {\n        public void Eat() \n        {\n            Console.WriteLine(\"小猫喜欢吃鱼!\");\n        }\n    }\n\nclass Dog \n    {\n\t    //Sleep方法报错\n        public abstract void Sleep() ;\n    }\n","answer":"A","a":"抽象类可以不包含抽象方法，但是含有抽象方法的类必须定义为抽象类。","b":"抽象方法不允许有方法体。","c":"子类继承于抽象类的时候必要重写抽象类中所有的抽象方法，除非子类也是抽象类。","d":"抽象类不允许实例化，只能够实例化其非抽象子类对象。"},{"contentType":"单选题","content":"对于下列代码的出错原因,描述正确的是（）\n\nabstract class Animal\n    {\n\t    //Eat()方法报错\n        public abstract void Eat() \n        {\n            Console.WriteLine(\"动物需要吃东西!\");\n        }\n    }","answer":"B","a":"单词的拼写出现错误，导致代码出错。","b":"抽象方法不允许有方法体，导致代码出错。","c":"抽象方法的命名不够规范，导致代码出错。","d":"与之相关的代码出错，导致代码出错。"},{"contentType":"单选题","content":"对于下列代码的出错原因,描述正确的是（）\nabstract class Appliance\n    {\n        public abstract void Charge();\n    }\n    //MobilePhone位置报错\n    class MobilePhone : Appliance\n    {\n        public void Call()\n        {\n            Console.WriteLine(\"手机可以打电话。\");\n        }\n    }","answer":"C","a":"电器类Appliance中有隐藏错误，导致MobilePhone类在继承的时候出现错误。 ","b":"MobilePhone单词拼写错误。","c":"子类MobilePhone继承于抽象类Appliance的时候必须要重写抽象类Appliance中所有的抽象方法，除非子类也是抽象类。","d":"其他关联错误。"},{"contentType":"单选题","content":"泛型方法的类型参数表用什么分割（）","answer":"A","a":"用<>分隔","b":"用,分隔","c":"用\"\"分隔","d":"用\\分隔"},{"contentType":"多选题","content":"泛型方法的类型参数指定了方法的什么内容（）","answer":"AB","a":"实参的类型","b":"返回类型","c":"形参的类型","d":"什么都没指定"},{"contentType":"单选题","content":"泛型集合所在的命名空间是（）","answer":"A","a":"System.Collections.Generic","b":"System.Collections","c":"System.Generic","d":"以上都不对"},{"contentType":"单选题","content":"根据以下代码，描述正确的是（） \npublic class Student\n    {\n        public string name;\n        public string Name\n        {\n            get { return name; }\n        }\n    }","answer":"B","a":"Name具有写入权限","b":"Name具有读取权限","c":"Name具有读取，也有写入权限","d":"Name无读取，也无写入权限"},{"contentType":"单选题","content":"关于C#中抽象类的说法，错误的是（）","answer":"C","a":"抽象类可以不包含抽象方法，但是含有抽象方法的类必须定义为抽象类。","b":"抽象方法不允许有方法体。","c":"子类继承于抽象类的时候没有必要重写抽象类中所有的抽象方法，即便子类不是抽象类。","d":"抽象类不允许实例化，只能够实例化其非抽象子类对象。"},{"contentType":"单选题","content":"关于Dictionary<k,v>，描述错误的是（）","answer":"A","a":"可以通过下标获取值","b":"可以通过键获取值","c":"描述的是键值对","d":"Keys属性表示键集合"},{"contentType":"单选题","content":"关于List<T>，描述错误的是（）","answer":"B","a":"是ArrayList的泛型版","b":"可以通过键获取值","c":"可以通过下标获取值","d":"可以调用Insert方法将元素添加到指定位置"},{"contentType":"单选题","content":"关于抽象方法和虚方法的区别说法不正确的是（）","answer":"D","a":"抽象方法和虚方法都是为了实现多态的功能。","b":"抽象方法只提供一个功能名称，要求子类必须实现该功能。","c":"虚方法使用关键字virtual修饰。","d":"虚方法虽然不止提供了功能名称还提供了默认的实现方式，但是子类还是必须重新实现该功能。"},{"contentType":"多选题","content":"关于对象的概念，下列说法正确的有（）","answer":"ABD","a":"对象是类的实例","b":"独一无二存在的个体","c":"对象是虚拟的","d":"客观存在的"},{"contentType":"单选题","content":"关于对象的使用，下列说法正确的是（）","answer":"B","a":"声明后就可以使用","b":"声明并且使用new关键字创建对象后才能使用","c":"创建类之后就可以使用对象","d":"声明后可以调用方法，使用new关键字创建对象后才能调用字段"},{"contentType":"单选题","content":"关于多态的实现方式以下不正确的是（）","answer":"C","a":"使用new关键字隐藏父类的方法","b":"使用override关键字重写父类的方法","c":"使用public完全公开父类的方法","d":"使用virtual关键字定义父类方法为虚方法"},{"contentType":"单选题","content":"关于泛型的特点，描述错误的是（）","answer":"C","a":"泛型是C#2.0新增加的功能","b":"不会强行对值类型装箱和拆箱","c":"数据类型默认为Object","d":"提高运行的性能"},{"contentType":"多选题","content":"关于构造函数，下列说法正确的有（）","answer":"ABC","a":"每个类都会默认的无参构造函数","b":"构造函数也可以重载","c":"构造函数是在使用new关键字创建对象时系统自动调用的","d":"在类中添加了一个有参的构造函数后，依然还可以使用无参的构造函数创建对象"},{"contentType":"多选题","content":"关于类与对象的关系，下列说法正确的有（）","answer":"ABCD","a":"类是抽象的","b":"对象是具体的","c":"对象是类的实例","d":"类是对象的抽象"},{"contentType":"单选题","content":"关于以下C#代码的说法正确的是（）\npublic abstract class Animal\n    {\n        public abstract void Eat();\n    }\n    public class Tiger : Animal\n    {\n        public override void Eat()\n        {\n            Console.WriteLine(\"老虎吃动物\");\n        }\n    }\nclass Program: Tiger\n    {\n        static void Main(string[] args)\n        {\n            Tiger tiger = new Tiger();\n            tiger.Eat();\n        }\n    }","answer":"B","a":"代码正确,但没有输出","b":"代码正确,并且输出为\"老虎吃动物\";","c":"代码错误,因为Program类没有实现抽象基类Animal中的抽象方法","d":"代码错误,因为抽象基类Animal的Eat方法没有实现"},{"contentType":"单选题","content":"观察下列代码，给出对应的结果（）：        ArrayList list = new ArrayList() { };\n        Customer teng = new Customer(\" 马腾 \", 32, \" 汕头市 \");\n        Customer yun = new Customer(\" 马云 \", 33, \" 汕头市 \");             list.Add(teng);\nlist.Add(yun);                     Console.WriteLine((list[2] as Customer).Name);","answer":"C","a":"程序编译不通过，不能运行","b":"马云","c":"程序运行报错","d":"空字符串"},{"contentType":"单选题","content":"观察下列代码，判断最后输出的结果：        Customer jun = new Customer(\" 李军 \",32,\" 广州 \"); \n        Customer yun = new Customer(\" 王云 \", 28, \" 杭州 \"); \n        Customer si = new Customer(\" 雷斯 \", 43, \" 美国 \"); \n        ArrayList list = new ArrayList(2);\n        list.Add(jun);\n        list.Add(yun);\n        list.Add(si);\n        Customer cust = list[1] as Customer;\n        Console.WriteLine(\"2 号客户：{0}\", cust.Name);","answer":"C","a":"程序出错","b":"2号客户：李军","c":"2号客户：王云","d":"2号客户：雷斯"},{"contentType":"单选题","content":"观察下列代码，找出错误的行，并修改正确的选项是（）               ArrayList list = new ArrayList() { };\n        Customer teng = new Customer(\" 马腾 \", 32, \" 汕头市 \");\n        Customer yun = new Customer(\" 王云 \", 28, \" 杭州市 \");\n        Customer si= new Customer(\" 李军 \", 25, \" 仙桃市 \");\n        list.Add(teng);\n        list.Add(yun);\n        list.Add(si);\n        Console.WriteLine(\" 排队等待的客户有：\");\n        for (int i = 0; i < list.Length; i++)\n        {-----(1)\n\tConsole.WriteLine(\"{0} 号：{1}\", i+1, (list[i] as Customer).Name);\n        }","answer":"B","a":"没有错","b":"（1）List.Length改成List.Count","c":"（1）List.Length改成List.Count()","d":"（1）List.Length改成List.Length()"},{"contentType":"单选题","content":"观察下列代码得出,选出正确的结果（）        ArrayList list = new ArrayList(2);\nlist.Add(jun);\nlist.Add(yun);\nlist.Add(si);\nlist.RemoveAt(0);","answer":"A","a":"集合里还有2个对象","b":"程序出错","c":"集合里没有对象了","d":"集合里还有1个对象"},{"contentType":"单选题","content":"观察下列代码给出最后的结果：                Customer jun = new Customer(\" 李军 \",32,\" 广州 \"); // 创建客户 1\n        Customer yun = new Customer(\" 王云 \", 28, \" 杭州 \"); // 创建客户 2\n        Customer si = new Customer(\" 雷斯 \", 43, \" 美国 \"); // 创建客户 3\n        ArrayList list = new ArrayList(2); list.Add(jun);\n        Console.WriteLine(\" 集合可存储元素数：{0}\", list.Capacity);\n        Console.WriteLine(\" 集合实际元素数：{0}\", list.Count);","answer":"A","a":"集合可存储元素数：2集合实际元素数：1","b":"集合可存储元素数：1集合实际元素数：1","c":"集合可存储元素数：2集合实际元素数：2","d":"集合可存储元素数：1集合实际元素数：2"},{"contentType":"单选题","content":"观察下列代码给出最后的结果：        ArrayList list = new ArrayList(2); \n        Console.WriteLine(\" 集合可存储元素数：{0}\", list.Capacity);\n        Console.WriteLine(\" 集合实际元素数：{0}\", list.Count);","answer":"C","a":"集合可存储元素数：0集合实际元素数：0","b":"集合可存储元素数：0集合实际元素数：2","c":"集合可存储元素数：2集合实际元素数：0","d":"集合可存储元素数：0集合实际元素数：1"},{"contentType":"单选题","content":"观察下列代码给出最后的结果：        Customer jun = new Customer(\" 李军 \",32,\" 广州 \"); // 创建客户 1\n        Customer yun = new Customer(\" 王云 \", 28, \" 杭州 \"); // 创建客户 2\n        Customer si = new Customer(\" 雷斯 \", 43, \" 美国 \"); // 创建客户 3\n        ArrayList list = new ArrayList(2); \n          list.Add(jun);\n           list.Add(yun);\n        list.Add(si);\n        Console.WriteLine(\" 集合可存储元素数：{0}\", list.Capacity);\n        Console.WriteLine(\" 集合实际元素数：{0}\", list.Count);\n}","answer":"D","a":"集合可存储元素数：2集合实际元素数：2","b":"集合可存储元素数：2集合实际元素数：1","c":"集合可存储元素数：3集合实际元素数：3","d":"集合可存储元素数：4集合实际元素数：3"},{"contentType":"单选题","content":"含有一个或多个抽象方法的类称为（）","answer":"A","a":"抽象类","b":"具体类","c":"虚基类","d":"派生类"},{"contentType":"多选题","content":"类的成员可以包含（）","answer":"ABC","a":"字段","b":"属性","c":"方法","d":"条件"},{"contentType":"单选题","content":"类的定义必须使用（）关键字。","answer":"B","a":"public","b":"class","c":"static","d":"namespace"},{"contentType":"单选题","content":"类的特征使用（）来描述。","answer":"B","a":"条件","b":"属性","c":"方法","d":"事件"},{"contentType":"单选题","content":"类的行为使用（ ）来描述。","answer":"C","a":"字段","b":"属性","c":"方法","d":"事件"},{"contentType":"多选题","content":"类是具有共同（）和（）的一类事物的统称。","answer":"AC","a":"特征","b":"抽象","c":"行为","d":"实例"},{"contentType":"单选题","content":"类最多只能有一个父类这表现了类的（）","answer":"C","a":"封装性","b":"传递性","c":"单根性","d":"规律性"},{"contentType":"单选题","content":"面向对象程序设计中，把对象的属性和行为组织在同一个模块内的机制叫做（）","answer":"C","a":"抽象","b":"继承","c":"封装","d":"多态"},{"contentType":"多选题","content":"面向对象是一种对现实世界理解和抽象的方法，其优点有（）","answer":"ABCD","a":"易维护","b":"可重用","c":"易扩展","d":"灵活性好"},{"contentType":"单选题","content":"面向对象中，实例化的对象可以通过（）的方式调用类中方法。","answer":"B","a":"类名.方法()","b":"对象.方法()","c":"类名.字段","d":"对象.字段"},{"contentType":"单选题","content":"面向对象中，实例化后的对象可以通过（）的方式修改或访问对象的属性值。","answer":"A","a":"对象.属性","b":"对象.方法()","c":"类名.字段","d":"类名.方法()"},{"contentType":"单选题","content":"面向对象中，以下可以理解为 对象的有（）","answer":"D","a":"动物","b":"鲜花","c":"学校","d":"NBA中的姚明"},{"contentType":"单选题","content":"面向对象中，以下可以理解为 类的是（）","answer":"C","a":"车牌号为云A 86688的96路公共汽车","b":"北京故宫","c":"同学","d":"小红家名叫“旺财”的狗狗"},{"contentType":"单选题","content":"能将元素添加到 ArrayList 结尾处的方法是（）","answer":"A","a":"Add","b":"Remove","c":"Insert","d":"InsertAfter"},{"contentType":"多选题","content":"能移除ArrayList 里的元素的方法有哪些（）","answer":"AD","a":"Remove","b":"Reverse","c":"Delete","d":"RemoveAt"},{"contentType":"单选题","content":"实现文件的读写操作，需要引入的命名空间是（）","answer":"B","a":"using System","b":"using System.IO","c":"using System.file","d":"using System.data"},{"contentType":"单选题","content":"使用()关键字修饰的类不允许被继承（）","answer":"A","a":"sealed","b":"override","c":"delegate","d":"private"},{"contentType":"单选题","content":"属性与字段的对应关系是（）","answer":"B","a":"多个字段对应一个属性","b":"1个字段对应一个属性","c":"多个属性对应一个字段","d":"以上都不对"},{"contentType":"单选题","content":"通过类的（）特性，可以重复使用已有代码和数据。","answer":"A","a":"继承","b":"封装","c":"抽象","d":"多态"},{"contentType":"单选题","content":"下列代码报错的原因是(  )\n  public interface IAnimal \n    {\n\t    //Eat()方法报错\n        public void Eat();\n    }\n","answer":"B","a":"Eat()方法没有添加方法体，导致报错。","b":"Eat()方法作为IAnimal接口的成员方法，不允许添加任何访问修饰符，加了Public修饰，导致报错。","c":"IAnimal作为接口，前面加了Public访问修饰符修饰，导致报错。","d":"Eat()方法命名不规范，导致报错。"},{"contentType":"单选题","content":"下列代码描述正确的是：（） \nclass UserInfo\n    {\n        private string userNo;\n        private string userPwd;\n        public string UserNo\n        {\n            get;\n            set;\n        }\n        public string UserPwd\n        {\n            get;\n            set;\n        }\n\n        public UserInfo()\n        {\n            this.UserNo = \"zhangsan\";\n            this.userPwd = \"123\";\n        }\n    }\n static void Main(string[] args)\n        {\n            UserInfo us = new UserInfo();\n        }","answer":"B","a":"us.UserNo的值为null","b":"us.UserPwd的值为\"123\"","c":"us.UserNo的值为\"\"","d":"us.UserPwd的值为0"},{"contentType":"单选题","content":"下列代码需要输出”小狗喜欢吃骨头”，“小猫蹲着睡”，则需要在Main()方法中添加的代码是（）\n class Program\n    {\n        static void Main(string[] args)\n        {\n           //在这一个位置写入代码\n        }\n    }\n\n    abstract class Animal\n    {\n        public abstract void Eat();\n    }\n    \n    class Dog : Animal\n    {\n        public override void Eat()\n        {\n            Console.WriteLine(\"小狗喜欢吃骨头。\");\n        }\n\n        public  void Sleep()\n        {\n            Console.WriteLine(\"小狗趴着睡。\");\n        }\n    }\n\n    class Cat : Animal\n    {\n        public override void Eat()\n        {\n            Console.WriteLine(\"小猫喜欢吃鱼。\");\n        }\n\n        public void Sleep()\n        {\n            Console.WriteLine(\"小猫蹲着睡。\");\n        }\n    }\n\n\n\n\n\n\n","answer":"C","a":"Animal dog = new Dog();\n    dog.Eat();\n    Animal cat = new Cat();\ncat.Eat();","b":"Animal dog = new Dog();\n     dog.Eat();\n     Animal cat = new Cat();\n     cat.Sleep();","c":" Animal dog = new Dog();\n    dog.Eat();\n    Cat cat = new Cat();\ncat.Sleep();","d":"Dog dog = new Dog();\n    dog.Sleep();\n    Cat cat = new Cat();\ncat.Eat();"},{"contentType":"单选题","content":"下列代码运行的结果是（）\nclass One { public virtual void Show() { \n            Console.Write(\"One\"); \n }   }\n    class Two : One{public override void Show(){\n            Console.Write(\"Two\");\n      }}\nclass Program {static void Main(string[] args) {\n            One obj = new Two();\n            obj.Show();\n   } }","answer":"C","a":"One","b":"One Two","c":"Two","d":"Two  One"},{"contentType":"单选题","content":"下列对ArrayList的常用方法描述错误的是（）","answer":"C","a":"Clear()清除所有元素","b":"Insert()将元素添加到指定位置","c":"Add()将元素添加到 ArrayList 开头处    ","d":"Reverse()将 ArrayList 中的元素顺序反转"},{"contentType":"单选题","content":"下列对ArrayList的常用方法描述正确的是（）","answer":"A","a":"Sort()对 ArrayList 中的元素排序","b":"Reverse()将 ArrayList 中的元素排序","c":"TrimToSize()将 ArrayList 容量数设置为初始值","d":"Remove()  清除所有元素"},{"contentType":"单选题","content":"下列关于 List<T> 的常用方法说法正确的是（）","answer":"C","a":"Sort()将 List<T> 中的元素顺序反转","b":"Reverse()对 List<T> 中的元素排序","c":"Remove()移除 List<T> 中指定的元素","d":"RemoveAt()移除 List<T> 中所有元素"},{"contentType":"单选题","content":"下列关于抽象方法说法错误的是（）","answer":"C","a":"使用abstract关键字修饰。","b":"只能够定义在抽象类中。","c":"可以写方法体在抽象方法中。","d":"子类必须重写抽象方法。"},{"contentType":"单选题","content":"下列关于抽象类和接口的说法错误的是（）","answer":"A","a":"抽象类是一种特殊的类，既然是类，所以它就可以实例化。","b":"抽象类侧重于有继承关系的一组对象。","c":"接口侧重于定义一组行为规则。","d":"接口用于多个不同种类的对象具有相同的行为或功能的场合。"},{"contentType":"单选题","content":"下列关于对虚方法的描述正确的有（）","answer":"B","a":"不可以在派生类中以override覆盖此方法","b":"在派生类中的虚方法若在子类不覆盖也可由对象调用","c":"虚方法可以有方法的实现，也可以不实现","d":"以上说法都正确"},{"contentType":"单选题","content":"下列关于泛型集合创建正确的是（）","answer":"A","a":"        List<Customer> list = new List<Customer>();","b":"        List<Customer>() list = new List<Customer>();","c":"        List<Customer> () list = new List<Customer>(5);","d":"        List<Customer> (5) list = new List<Customer>();"},{"contentType":"多选题","content":"下列关于泛型描述正确的是（）","answer":"ABCD","a":"增加了极大的效率和灵活性","b":"可重用性","c":"高效性","d":"类型安全性"},{"contentType":"单选题","content":"下列关于构造函数的说法，错误的是（）","answer":"D","a":"构造函数的函数名和类名相同","b":"构造函数可以重载","c":"构造函数可以带有参数","d":"可以指定构造函数的返回值"},{"contentType":"单选题","content":"下列关于集合的创建，正确的是（）","answer":"B","a":"List<int>  list = new List();","b":"List<int>  list = new List<int>();","c":"ArrayList<int> list = new ArrayList();","d":"ArrayList<int> list = new ArrayList<int>();"},{"contentType":"单选题","content":"下列关于集合的说法，正确的是（）","answer":"A","a":"Count属性可以获取集合中实际存储的元素个数","b":"Capacity属性可以获取集合中实际存储的元素个数","c":"Hashtable存储的元素是按添加的先后顺序排列的","d":"ArrayList可以通过键来访问对应值"},{"contentType":"单选题","content":"下列关于继承和接口的说法，正确的是（）","answer":"B","a":"C#不允许实现多个接口，但可以有多个父类","b":"C#允许实现多个接口，但不能有多个父类","c":"C#不允许实现多个接口，也不允许有多个父类","d":"C#允许实现多个接口，也允许有多个父类"},{"contentType":"单选题","content":"下列关于接口的说法正确的是（）","answer":"D","a":"使用关键字abstract关键字。","b":"可以包含字段和已实现成员。","c":"子类通过override实现抽象方法。","d":"子类直接实现所有成员。"},{"contentType":"多选题","content":"下列关于接口定义时需要注意的事项说法错误的是( )","answer":"CD","a":"接口名一般使用大写的字母”I”开头，表明它是接口类型。","b":"接口可以包含方法、属性、事件和索引器，但是不能够包含字段。","c":"接口中定义的成员可以有具体的实现，方便子类使用。","d":"接口中的成员方法允许添加访问修饰符。"},{"contentType":"多选题","content":"下列关于接口和抽象类的说法错误的是（）","answer":"CD","a":"抽象类使用abstract关键字定义。","b":"接口使用interface关键字定义。","c":"抽象类不可以包含字段和已实现成员。","d":"接口可以有字段，也可以包含所有的成员。 "},{"contentType":"单选题","content":"下列关于属性中的访问器的说法，正确的是（）","answer":"B","a":"属性中可以不包含任何访问器","b":"属性中可以只有get访问器，也可以只有set访问器","c":"属性中只能有get访问器或set访问器，不能同时包含","d":"属性中必须同时包含get访问器和set访问器"},{"contentType":"多选题","content":"下列关于虚方法的说法，正确的有（）","answer":"ABC","a":"使用virtual关键字修饰虚方法","b":"父类中的虚方法可以被其子类重写","c":"虚方法必须有自己的方法体","d":"虚方法一般定义在sealed修饰的类中"},{"contentType":"单选题","content":"下列关于虚函数的描述中，错误的是（）","answer":"C","a":"虚函数是一个成员函数","b":"虚函数具有继承性","c":"静态成员函数可以说明为虚函数","d":"在类的继承的层次结构中，虚函数可被用来重写"},{"contentType":"单选题","content":"下列描述错误的是（）","answer":"D","a":"类不可以多继承而接口可以","b":"抽象类自身可以定义成员而接口不可以","c":"抽象类和接口都不能被实例化","d":"一个类可以有多个基类"},{"contentType":"单选题","content":"下列描述的对象中，能够作为抽象类的是（）","answer":"B","a":"小狗","b":"动物","c":"小猪","d":"小猫"},{"contentType":"单选题","content":"下列描述中，()不是方法重载。","answer":"B","a":"void Show(){}和void Show(string name){}","b":"string Show(string name){}和void Show(string name){}","c":"string Show(int age){}和void Show(string name){}","d":"void Show(int age){}和void Show(int age,string name){}"},{"contentType":"单选题","content":"下列描述中，错误的是（）","answer":"D","a":"基类的protected成员在public派生类中仍然是protected成员","b":"基类的private成员在public派生类中是不可访问的","c":"基类public成员在private派生类中是private成员","d":"基类public成员在protected派生类中仍是public成员"},{"contentType":"单选题","content":"下列描述中，正确定义抽象类语法是（）","answer":"B","a":"访问修饰符 enum 名称{内容…} ","b":"abstract class 名称{内容…}","c":"[访问修饰符] interface 名称{内容…}","d":"访问修饰符 struct 名称{内容…}"},{"contentType":"单选题","content":"下列哪个属于 获取ArrayList 实际包含的元素个数的属性（）","answer":"B","a":"Length","b":"Count","c":"Size","d":"Capacity "},{"contentType":"单选题","content":"下列那个方法可以去掉HashTable里的所有元素（）","answer":"D","a":"Remove","b":"ContainsKey","c":"Delete","d":"Clear"},{"contentType":"单选题","content":"下列说法关于Dictionary<K,V> 的常用方法说法错误的是（）","answer":"D","a":"Remove() 从 Dictionary<K,V>中移除带有指定键的元素","b":"Add()将带有指定键和值的元素添加到 Dictionary<K,V>中","c":"ContainsKey()   确定 Dictionary<K,V>中是否包含指定键","d":"AddAt()将带有指定键和值的元素添加到 Dictionary<K,V>中"},{"contentType":"单选题","content":"下列说法关于Dictionary<K,V> 的常用方法说法正确的是（）","answer":"C","a":"Remove() 从 Dictionary<K,V>中移除全部的元素","b":"Delete()移除 Dictionary<K,V>中所有元素","c":"ContainsValue() 确定 Dictionary<K,V>中是否包含指定值","d":"AddAt(object key, object value)将带有指定键和值的元素添加到 Dictionary<K,V>中"},{"contentType":"多选题","content":"下列说法关于Hashtable 正确的是（）","answer":"ABD","a":"可用于处理 key/value( 键 / 值 ) 对","b":"key 通常用于快速查找","c":"value 用于存储对应于 key 的值,key不区分大小写","d":"Hashtable 中键值均为 object 类型"},{"contentType":"单选题","content":"下列说法正确的是（）","answer":"C","a":"虚方法不可以在派生类中重写","b":"sealed前可以使用abstract修饰","c":"声明密封方法时，sealed修饰符总是和override修饰符同时使用","d":"以上说法全部正确"},{"contentType":"多选题","content":"下列说法正确的有（）","answer":"ABCD","a":"密封类不能作为基类被别的元素继承","b":"密封类可以继承非密封类或接口","c":"密封类中不能声明受保护成员","d":"密封类中不能声明虚方法"},{"contentType":"单选题","content":"现有Customer类，实例化类的写法正确的是（）","answer":"B","a":"Customer() cm = new Customer();","b":"Customer cm = new Customer();","c":"Customer  = new Customer();","d":"Customer cm =Customer;"},{"contentType":"单选题","content":"现有Student类，构造函数对其属性Name进行赋值操作，（）处填充正确代码。\nclass Student\n        {\n            private string name;     \n            public String Name\n            {\n                get;\n                set;\n            }\n            public Student(string name)\n            {\n                （）\n            }\n        }","answer":"C","a":"this.name=Name","b":"Name == name","c":"this.Name = name;","d":"name=Name"},{"contentType":"单选题","content":"现有华为Mate30手机信息：颜色-黑色，价格-5000元，功能-打电话；要求定义一个手机类，可以作为类中方法的是：","answer":"C","a":"手机颜色","b":"手机价格","c":"手机功能","d":"都不可以"},{"contentType":"单选题","content":"序列化对象需要引入的命名空间是（）","answer":"C","a":"using System","b":"using System.IO","c":"using System.Runtime.Serialization.Formatters.Binary;","d":"using System.data"},{"contentType":"单选题","content":"以下（   ）是判断用户是否点击对话框的确认按钮。","answer":"A","a":"DialogResult.OK","b":"DialogResult.Abort","c":"DialogResult.Cancel","d":"DialogResult.None"},{"contentType":"单选题","content":"以下FileMode 的哪一项枚举值可以用来打开文件，如果文件不存在，则引发异常（）","answer":"D","a":"CreateNew","b":"Create","c":"OpenOrCreate","d":"Open"},{"contentType":"单选题","content":"以下代码，输出结果为：（）\nclass Hero\n    {\n        private string name;\n        private int attack;\n        public string Name\n        {\n            get;\n            set;\n        }\n        public int Attack\n        {\n            get;\n            set;\n        }\n\n        public Hero(string name)\n        {\n            this.Name = name;\n            this.Attack = 180;\n        }\n    }\n\n        static void Main(string[] args)\n        {\n            Hero hero = new Hero(\"亚瑟\");\n            Console.WriteLine(\"姓名：{0},攻击：{1}\", hero.Name, hero.Attack);\n        }","answer":"D","a":"姓名：\"\",攻击：0","b":"姓名：\"亚瑟\",攻击：0","c":"姓名：\"\",攻击：180","d":"姓名：亚瑟,攻击：180"},{"contentType":"单选题","content":"以下代码输出结果是：（）\nstatic void Main(string[] args)\n        {\nCommodity cake = new Commodity();\n            cake.name = \" 蛋糕 \";\n            cake.price = 18;\n            cake.productionDate = DateTime.Parse(\"2018-9-18\");\n            cake.factory = \" 武汉美食食品 \";\n            cake.expire = 90;\n            Console.WriteLine(cake.name);\n\n        }\n","answer":"C","a":"cake.name = \" 蛋糕 \";","b":" 18","c":"蛋糕","d":"没有"},{"contentType":"单选题","content":"以下代码运行结果（）\npublic class Customer\n    {\n        public string name;\n        public int age;\n        public int Age\n        {\n            set { age = value; }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Customer liu = new Customer();\n            liu.Age = 300;\n            Console.WriteLine(liu.Age);\n        }\n    }","answer":"D","a":"300","b":"100","c":"0","d":"代码出现错误"},{"contentType":"单选题","content":"以下代码运行结果依次为（）\nstatic void Show()\n        {\n            Console.WriteLine(\"大家好！\");\n        }\n\n        static void Show(string name)\n        {\n            Console.WriteLine(\"同学好！\");\n        }\n\n        static void Show(string name,int age)\n        {\n            Console.WriteLine(\"你们好！\");\n        }\n\n        static void Main(string[] args)\n        {\n            Show(\"刘备\", 20);\n            Show();\n            Show(\"张飞\");\n        }","answer":"A","a":"你们好！大家好！同学好！","b":"同学好！你们好！大家好！","c":"你们好！同学好！大家好！","d":"大家好！你们好！同学好！"},{"contentType":"多选题","content":"以下对序列化说法正确的是（）","answer":"BC","a":"将文件中的数据转化为对象","b":"指将对象实例的状态存储到存储媒体中的过程","c":"需要引入命名空间","d":"不能保存文字"},{"contentType":"单选题","content":"以下对于C#程序中密封类的关键字正确的是（）","answer":"D","a":"private","b":"static","c":"abstract","d":"sealed"},{"contentType":"多选题","content":"以下对于序列化说法错误的是（）","answer":"AD","a":"不可以序列化图片","b":"可以序列化图片","c":"可以序列化对象","d":"不可以序列化对象"},{"contentType":"多选题","content":"以下关于C#编程的说法，正确的是（）","answer":"AC","a":"使用sealed 关键字修饰的类，可避免类被继承","b":"在C#编程中，访问修饰符控制程序对类访问，如果不写访问修饰符，类的默认访问类型public","c":"在C#中，base关键字用于子类调用父类的构造方法","d":"在C#中，this关键字用于子类调用父类的构造函数"},{"contentType":"单选题","content":"以下关于C#代码的说法正确的是（）？Public abstract Animal  \n{ \n Public abstract void Eat();  \n Public void Sleep() { }  \n}","answer":"A","a":"该段代码正确","b":"代码错误，因为类中存在非抽象方法","c":"代码错误，因为类中的方法没有实现","d":"通过代码“Animal an = new Animal();”可以创建一个Animal对象"},{"contentType":"多选题","content":"以下那两项属于继承的两大特性（）","answer":"BC","a":"持久性","b":"单根性","c":"传递性","d":"安全性"},{"contentType":"单选题","content":"以下属性可以设置OpenFileDialog文件筛选器索引的是（）","answer":"D","a":"Filter","b":"CheckFileExists","c":"Title","d":"FilterIndex "},{"contentType":"多选题","content":"以下属于读取文件的流程的是（）","answer":"ABD","a":"创建文件流","b":"创建读取器","c":"关闭写入器","d":"关闭文件流"},{"contentType":"多选题","content":"以下属于面向对象特性的是（）","answer":"ABD","a":"继承","b":"多态","c":"抽象","d":"封装"},{"contentType":"多选题","content":"以下属于文件对话框的是（）","answer":"ACD","a":"OpenFileDialog","b":"OpenDialog","c":"SaveFileDialog","d":"FolderBroswerDialog"},{"contentType":"单选题","content":"以下说法错误的是（）","answer":"C","a":"继承是指子类可以沿用父类的某些行为和特征","b":"通过继承，子类将自动拥有父类可被继承的字段、属性、方法等","c":"一个类可以有多个父类","d":"一个类可以有多个子类"},{"contentType":"单选题","content":"以下文件操作方法，（   ）可以用来删除文件。","answer":"B","a":"Move()","b":"Delete()","c":"Copy()","d":"Exists()"},{"contentType":"单选题","content":"以下文件对话框，可以用来打开文件的是（）","answer":"A","a":"OpenFileDialog","b":"SaveFileDialog","c":"FolderBroswerDialog","d":"OpenDialog"},{"contentType":"单选题","content":"以下文件夹操作方法，（  ）可以用来删除非空文件夹。","answer":"A","a":"Delete(string, bool) ","b":"Delete(string) ","c":"Move()","d":"CreateDirectory() "},{"contentType":"单选题","content":"在A类中定义protected的属性Name，下列说法正确的（）","answer":"A","a":"定义B类继承A类，则B类也具有Name属性","b":"在B类中创建A类对象，可以通过“对象.成员”访问Name","c":"无论B类是否继承A类，Name只能在A类中使用","d":"Name可以在任何地方使用"},{"contentType":"单选题","content":"在c#中，可以通过( )实现方法重载。","answer":"A","a":"方法名相同，不同的参数个数","b":"方法名相同，不同的参数名称","c":"不同的方法名称，相同的参数个数","d":"相同的方法名称和参数个数，不同的返回值"},{"contentType":"多选题","content":"在C #编程中，下列说法正确的有（）","answer":"CD","a":"在C#中，一个类只能被一个子类继承","b":"在C#中，接口中的方法可以具体实现","c":"在C#中，可以实现多个接口，但只能继承一个父类","d":"在C#编程中，如果不写访问修饰符，类成员的默认访问类型是private"},{"contentType":"单选题","content":"在C#程序中，方法的默认访问修饰符是以下哪一项（）","answer":"B","a":"public","b":"private","c":"protected","d":"internal"},{"contentType":"单选题","content":"在C#程序中,关于抽象类描述错误的是（）","answer":"A","a":"抽象类不可以被继承","b":"抽象类中可以定义字段、属性","c":"抽象类中可以定义虚方法","d":"抽象类可以定义抽象方法"},{"contentType":"多选题","content":"在C#程序中，关于密封方法描述正确的是（）","answer":"AC","a":"密封方法可以不定义在密封类中","b":"所有的方法都可以进行密封","c":"使用override重写后的方法可以被密封","d":"以上说法都正确"},{"contentType":"单选题","content":"在C#程序中，类的默认访问修饰符是以下哪一项（）","answer":"D","a":"public","b":"private","c":"protected","d":"internal"},{"contentType":"单选题","content":"在C#程序中,实现抽象类的关键字是（）","answer":"A","a":"abstract","b":"overried","c":"new","d":"sealed"},{"contentType":"单选题","content":"在C#程序中,实现方法重写时使用的关键字是（）","answer":"A","a":"override","b":"new","c":"abstract","d":"sealed"},{"contentType":"多选题","content":"在C#程序中，下列说法正确的是（）","answer":"AC","a":"new 关键字可以显式隐藏从基类继承的成员","b":"new 关键字不可以显式隐藏从基类继承的成员","c":"子类中藏父类成员时若省略new关键字，程序不会报错,但会发出警告","d":"子类中藏父类成员时若省略new关键字，程序不会报错且不会发出警告"},{"contentType":"单选题","content":"在C#程序中，以下哪一项不属于访问修饰符（）","answer":"A","a":"static","b":"public","c":"private","d":"protected"},{"contentType":"单选题","content":"在C#程序中，以下说法错误的是（）","answer":"D","a":"不管是重写还是覆盖都不会影响父类自身的功能","b":"重写基方法必须具有与override方法相同的签名","c":"override声明不能更改virtual方法的可访问性，且override方法与virtual方法必须具有相同级别访问修饰符","d":"可以使用new、static、virtual修饰符修改override方法"},{"contentType":"单选题","content":"在C#程序中，以下说法错误的是（）","answer":"C","a":"重写属性声明必须指定与继承的属性完全相同的访问修饰符、类型和名称","b":"重写的属性必须是virtual、abstract或override","c":"静态方法可以被重写","d":"抽象方法可以被重写"},{"contentType":"单选题","content":"在C#程序中，以下说法错误的是（）","answer":"B","a":"父类中有abstract，那么子类同名方法必定有override","b":"父类中有abstract，子类同名方法不一定定有override","c":"override必定有父子类关系","d":"override重写用于扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现"},{"contentType":"单选题","content":"在C#程序中，子类需隐藏父类同名方法可以使用（）关键字。","answer":"A","a":"new","b":"as","c":"abstract","d":"override"},{"contentType":"单选题","content":"在C#程序中关于抽象类的定义，以下描述有误的是（）","answer":"B","a":"public abstract class A{}","b":"public  class  abstract A{}","c":"abstract public  class A{}","d":"abstract class A{}"},{"contentType":"多选题","content":"在C#当中B类继承A类，A类使用（）访问修饰符的成员在B类可以使用。","answer":"ACD","a":"public","b":"private","c":"protected","d":"protected internal"},{"contentType":"单选题","content":"在C#中，关于 override与重载的说法正确的是（）","answer":"B","a":"override是指在同一类中，存在多个具有相同方法名，而不同参数列表的方法","b":"重载是指在同一类中，存在多个具有相同方法名，而不同参数列表的方法","c":"重载要求父类与子类之间，方法名和参数类型、数量、顺序完全一致","d":"重载是对父类中方法的扩展,子类继承了父类,重载后,子类不但得到了父类的东西，而且还可以有自己的东西"},{"contentType":"单选题","content":"在C#中，关于ArrayList和List的说法正确的是（）","answer":"C","a":"从ArrayList获取集合中某个元素时，不需要进行类型转换","b":"从List获取集合中某个元素时，需要进行类型转换","c":"从ArrayList获取集合中某个元素时，需要进行类型转换","d":"从ArrayList和List获取集合中某个元素时，都不需要进行类型转换"}]