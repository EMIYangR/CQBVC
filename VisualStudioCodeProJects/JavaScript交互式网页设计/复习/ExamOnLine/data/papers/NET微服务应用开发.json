[{"contentType":"多选题","content":"在.NET微服务中，下面对微服务的描述正确的有（     ）【选三项】","answer":"ABC","a":"从面向服务的架构到服务化架构，再到微服务架构，是一个逐步演进的过程","b":"微服务架构并不是什么技术创新，而是开发过程发展到一定阶段对技术架构的要求，是在实践中不断摸索而来的","c":"微服务架构由多个相对独立的应用程序组成，并且应用程序被部署到多个服务器中","d":"单体架构将所有的功能打包成一个exe或dll文件，并部署到单个服务器中，比微服务架构耦合度低"},{"contentType":"多选题","content":"在.NET微服务中，以下对于微服务的优点描述正确的有（     ）【选三项】","answer":"ABD","a":"聚焦业务功能或需求","b":"松耦合","c":"分布式系统简单并易于维护","d":"只包含业务逻辑代码"},{"contentType":"单选题","content":"在.NET微服务中，微服务架构应用程序的缺点不包括（     ）","answer":"D","a":"微服务架构可能带来过多的操作","b":"微服务的分布式系统可能复杂并难以管理","c":"分布式系统部署和跟踪问题难","d":"当服务器数量减少后，管理复杂性增加"},{"contentType":"多选题","content":"在.NET微服务中，微服务架构程序的设计过程中，遵循的原则正确的有（     ）【选三项】","answer":"ACD","a":"持续演进原则。","b":"水平划分优先原则。","c":"自动化驱动原则。","d":"服务自治、接口隔离原则"},{"contentType":"多选题","content":"在.NET微服务中，以下属于微服务架构的有（     ）【选三项】","answer":"ACD","a":"Dubbo","b":"MVC","c":"Spring Cloud","d":"Orleans"},{"contentType":"多选题","content":"在.NET微服务中，以下对于.NET Core平台的特点描述正确的有（     ）【选两项】","answer":"BD","a":"只能用在Windows平台","b":"部署灵活","c":"源代码不开放","d":"由Microsoft支持"},{"contentType":"多选题","content":"在.NET微服务中，以下属于.NET Core平台组成的有（     ）【选三项】","answer":"ABD","a":".NET Core运行时","b":"ASP.NET Core运行时","c":"Controller控制器","d":"dotnet工具"},{"contentType":"单选题","content":"在.NET Core中, 在以下哪一个命令用于创建新的项目、配置文件或解决方案（     ）","answer":"A","a":"dotnet new","b":"dotnet restore","c":"dotnet build","d":"dotnet publish"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于恢复项目的依赖项和工具（     ）","answer":"B","a":"dotnet new","b":"dotnet restore","c":"dotnet build","d":"dotnet publish"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于生成项目及其所有依赖项（     ）","answer":"C","a":"dotnet new","b":"dotnet restore","c":"dotnet build","d":"dotnet publish"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于部署到托管系统（     ）","answer":"D","a":"dotnet new","b":"dotnet restore","c":"dotnet build","d":"dotnet publish"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于运行源代码（     ）","answer":"A","a":"dotnet run","b":"dotnet test","c":"dotnet clean","d":"dotnet store"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于执行单元测试的.NET测试驱动程序（     ）","answer":"B","a":"dotnet run","b":"dotnet test","c":"dotnet clean","d":"dotnet store"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于清除项目输出（     ）","answer":"C","a":"dotnet run","b":"dotnet test","c":"dotnet clean","d":"dotnet store"},{"contentType":"单选题","content":"在.NET Core中,以下哪一个命令用于存储（     ）","answer":"D","a":"dotnet run","b":"dotnet test","c":"dotnet clean","d":"dotnet store"},{"contentType":"单选题","content":"在.NET微服务中，基于任务异步模式的Task<TResult>类和Task类属于哪一个命名空间（     ）","answer":"C","a":"System.Threading.Tasks.Tasks","b":"System.Threading.Tasks.Task","c":"System.Threading.Tasks","d":"System.Threading.Task"},{"contentType":"单选题","content":"在.NET Core中,一般通过加入（     ）关键字来调用异步方法？","answer":"B","a":"async","b":"await","c":"Task","d":"Run"},{"contentType":"单选题","content":"在.NET Core中,以下哪一项不属于异步编程模式（     ）","answer":"C","a":"异步编程模型（APM）","b":"基于事件的异步模式（EAP）","c":"基于类的异步模式（CAP）","d":"基于任务的异步模式（TAP）"},{"contentType":"单选题","content":"在.NET Core中,await仅可用于由（     ）关键字修饰的异步方法中","answer":"C","a":"Task","b":"await","c":"async","d":"Run"},{"contentType":"单选题","content":"在.NET Core中,使用TAP模式实现异步编程的步骤为（     ）","answer":"B","a":"1.创建异步方法\n2.调用异步方法\n3.关闭异步方法","b":"1.创建异步方法\n2.调用异步方法","c":"1.创建异步方法\n2.注册异步方法\n3.调用异步方法","d":"1.调用异步方法\n2.创建异步方法"},{"contentType":"单选题","content":"在.NET Core中,以下哪一项不是基于任务异步模式方法的返回值（     ）","answer":"C","a":"Task","b":"ValueTask","c":"ItemTask","d":"Task<TResult>"},{"contentType":"单选题","content":"在.NET微服务中，为了简化异步编程的过程，.NET Framework 4.5 在C#中引入了哪两个关键字（     ）","answer":"C","a":"await和task","b":"await和tasks","c":"await和async","d":"async和task"},{"contentType":"单选题","content":"在.NET Core中, 使用dotnet new创建的常用项目模板不包括以下哪一项（     ）","answer":"A","a":"winform","b":"classlib","c":"webapi","d":"web"},{"contentType":"单选题","content":"在.NET微服务中，以下哪一项不是微服务的特点（     ）","answer":"B","a":"项目交付速度较快","b":"不存在远程调用","c":"可重用性高","d":"需要额外考虑服务的注册发现、依赖关系、自治等问题"},{"contentType":"单选题","content":"在.NET微服务中，对创建异步任务方法描述错误的是（     ）","answer":"C","a":"不返回值的任务由System.Threading.Tasks.Task类表示","b":"返回值的任务由System.Threading.Tasks.Task<TResult>类表示","c":"Thread.Sleep(2)让线程休眠2秒","d":"使用Start()方法启动任务"},{"contentType":"多选题","content":"在.NET微服务中，使用ASP.NET Core可以实现以下哪些需求（     ）【选三项】","answer":"ABD","a":"创建Web应用程序和服务、IoT应用和移动后端。","b":"在Windows、macOS和Linux上使用喜爱的开发工具。","c":"创建Winform应用程序","d":"在.NET Core或.NET Framework上运行。"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core是一个跨平台的高性能（     ）","answer":"C","a":"开发工具","b":"闭源框架","c":"开源框架","d":"开发软件"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core主要支持Web Pages项目、MVC项目和Web API项目，不支持基于WebForm框架的（     ）程序项目","answer":"B","a":"windows桌面应用","b":"Web应用","c":"手机应用","d":"Linux桌面应用"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core Web应用程序项目使用（     ）配置文件","answer":"A","a":"appsettings.json","b":"Web.config","c":"Application.config","d":"App.config"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core项目中的JavaScript、图片和样式表文件都存放在（     ）文件夹下对应的子文件夹中","answer":"D","a":"Context","b":"根目录","c":"Content","d":"wwwroot"},{"contentType":"多选题","content":"在.NET微服务中，ASP.NET Core可以通过配置（     ）和（     ）实现跨域请求【选两项】","answer":"BD","a":"Config()方法","b":"Configure()方法","c":"ConfigServer()方法","d":"ConfigureServer()方法"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core项目中的路由配置、中间件配置、依赖配置都在（     ）文件中","answer":"B","a":"wwwroot","b":"Startup.cs","c":"Content","d":"App_start"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core应用程序本质上是一个独立的（     ）程序","answer":"C","a":"Web应用","b":"Web页面","c":"控制台应用","d":"桌面应用"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core应用程序的程序入口在（     ）文件中","answer":"A","a":"Program.cs","b":"Main.cs","c":"Startup.cs","d":"appsettings.json"},{"contentType":"单选题","content":"在ASP.NET Core项目中,Startup类的（     ）方法用于指定ASP.NET Core应用程序将如何响应每一个HTTP请求","answer":"B","a":"Build()","b":"Configure()","c":"Run()","d":"Main()"},{"contentType":"多选题","content":"在.NET微服务中，下面有关ASP.NET Core Web项目的创建操作，正确的步骤有（     ）【选两项】","answer":"AC","a":"“创建新项目”对话框，在其中选中“ASP.NET Core Web应用程序”模板","b":"“创建新项目”对话框，在其中选中“类库（.NET Core）”模板","c":"创建新的ASP.NET Core Web应用程序”对话框中，选择“Web应用程序（模型视图控制器）”项目类型","d":"创建新的ASP.NET Core Web应用程序”对话框中，选择“Angular”项目类型"},{"contentType":"单选题","content":"在ASP.NET Core项目中,Startup类的（     ）方法用来配置用于应用程序内的服务","answer":"C","a":"Configure()","b":"Build()","c":"ConfigureService()","d":"Config()"},{"contentType":"单选题","content":"在.NET微服务中，出于对客户访问安全的考虑，浏览器会阻止网页向其他网站（即其他区网络域）发送请求，此限制称为（     ）","answer":"A","a":"同源策略","b":"同等策略","c":"跨域策略","d":"同源限制"},{"contentType":"单选题","content":"在ASP.NET Core中, CORS策略选项中AllowAnyOrigin的描述，正确的是","answer":"B","a":"允许任何请求头","b":"允许所有来源","c":"允许任何HTTP方法","d":"允许特定来源的CORS请求"},{"contentType":"单选题","content":"在.NET微服务中，依赖注入是一种实现对象及其合作者或依赖项之间（     ）的技术","answer":"C","a":"消除耦合","b":"降低内聚","c":"松散耦合","d":"建立耦合"},{"contentType":"多选题","content":"在ASP.NET Core中,CORS策略选项中（     ）和（     ）是不安全的配置【选两项】","answer":"BC","a":"AllowAnyHeader","b":"AllowAnyOrigin","c":"AllowCredentials","d":"AllowAnyMethod"},{"contentType":"单选题","content":"在.NET微服务中，如果需要读取其他网站中的数据，需要允许其他站点对开发者的应用进行（     ）","answer":"A","a":"跨域请求","b":"跨网请求","c":"跨域访问","d":"跨域传递"},{"contentType":"单选题","content":"在ASP.NET Core中, 服务注册方法里（     ）是作用域生存期服务，以每个客户端请求（连接）一次就能创建服务","answer":"B","a":"AddTransient()","b":"AddScoped()","c":"AddSingleton()","d":"AddAll()"},{"contentType":"单选题","content":"在ASP.NET Core中,需要在ConfigureServices（     ）方法中调用（     ）方法添加跨域策略","answer":"A","a":"AddCors()","b":"Cors()","c":"Add()","d":"SetCors()"},{"contentType":"单选题","content":"在ASP.NET Core中,（     ）策略允许特定来源的CORS请求","answer":"B","a":"AllowAnyOrigin","b":"WithOrigins","c":"AllowCredentials","d":"AllowAnyHeader"},{"contentType":"多选题","content":"在ASP.NET Core中,Startup.cs文件中的配置有（     ）、（     ）和（     ）【选三项】","answer":"ABC","a":"路由配置","b":"中间件配置","c":"依赖配置","d":"网络配置"},{"contentType":"单选题","content":"在ASP.NET Core中,通过调用（     ）方法启动WebHost实例","answer":"C","a":"Bulid()","b":"Main()","c":"Run()","d":"Configure()"},{"contentType":"单选题","content":"在ASP.NET Core项目中,Startup类的Configure方法中app对象的（     ）方法可以加入使用路由的中间件","answer":"B","a":"UseHttpsRedirection(）","b":"UseRouting(）","c":"UseStaticFiles()","d":"UseAuthorization()"},{"contentType":"单选题","content":"在.NET微服务中，如果两个URL地址具有相同协议、主机名和端口，则它们具有（     ）","answer":"C","a":"相同的服务器","b":"相同的客户端","c":"相同的源","d":"相同的浏览器"},{"contentType":"单选题","content":"在ASP.NET Core中, CORS策略选项中（     ）策略表示设置公开的响应标头","answer":"D","a":"AllowAnyHeader","b":"WithOrigins","c":"WithHeaders","d":"WithExposedHeaders"},{"contentType":"多选题","content":"在.NET微服务中，ASP.NET Core配置以键值对的形式从各种配置源读取配置数据，可使用的配置源有（     ）【选三项】","answer":"BCD","a":"文本文件","b":"环境变量","c":"配置文件","d":"命令行参数"},{"contentType":"单选题","content":"在ASP.NET Core中,可在（     ）配置文件中更改服务器的启动地址或端口号","answer":"B","a":"web.config","b":"launchSetting.json","c":"appsetting.json","d":"appsetting.Development.json"},{"contentType":"单选题","content":"在ASP.NET Core中,默认配置文件是基于（     ）文件格式？","answer":"D","a":"字符串","b":"xml","c":"txt","d":"json"},{"contentType":"单选题","content":"在ASP.NET Core中,（     ）是程序调试时应用的配置文件","answer":"D","a":"web.config","b":"launchSetting.json","c":"appsetting.json","d":"appsetting.Development.json"},{"contentType":"单选题","content":"在ASP.NET Core中,（     ）是程序运行时应用的配置文件","answer":"C","a":"web.config","b":"launchSetting.json","c":"appsetting.json","d":"appsetting.Development.json"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core的配置文件中，配置键的约定哪项是正确的？","answer":"C","a":"键区分大小写","b":"键不能相同","c":"ConfigurationBinder类支持使用配置键中数组索引将数组绑定到对象","d":"在环境变量配置中，冒号分隔符适用于所有平台"},{"contentType":"多选题","content":"在.NET微服务中，ASP.NET Core的配置文件中，配置值的约定哪项是正确的？【选三项】","answer":"ACD","a":"值是字符串","b":"值可以为任意数据类型","c":"NULL值不能存储在配置中","d":"NULL值不能绑定到对象中"},{"contentType":"单选题","content":"在.NET微服务中，关于ASP.NET Core日志说法错误的是（     ）?","answer":"C","a":"日志是用来记录系统操作、用户操作、系统运行状态等技术","b":"一般记录日志目的为：故障定位和显示程序运行状态","c":"日志以键值对形式存储","d":"ASP.NET Core支持适用于各种内置和第三方日志记录提供程序的日志记录API"},{"contentType":"单选题","content":"在.NET微服务中，ASP.NET Core中,下面哪个日志级别表示无法处理的错误和异常信息（     ）?","answer":"D","a":"跟踪级别","b":"调试级别","c":"警告级别","d":"错误级别"},{"contentType":"单选题","content":"在ASP.NET Core中,下面（     ）日志级别最为严重?","answer":"D","a":"跟踪级别","b":"调试级别","c":"警告级别","d":"错误级别"},{"contentType":"单选题","content":"在ASP.NET Core中 , Ilogger对象里哪个扩展方法是用来设置错误日志信息格式并写入该信息的？（     ）","answer":"C","a":"LogCritical()","b":"LogDebug()","c":"LogError()","d":"LogWarnig()"},{"contentType":"单选题","content":"在ASP.NET Core中 , Ilogger对象里哪个扩展方法是用来设置警告日志信息格式并写入该信息的？（     ）","answer":"D","a":"LogCritical()","b":"LogDebug()","c":"LogError()","d":"LogWarnig()"},{"contentType":"单选题","content":"在ASP.NET Core中 , Ilogger对象里哪个扩展方法是用来设置调试日志信息格式并写入该信息的？（     ）","answer":"B","a":"LogCritical()","b":"LogDebug()","c":"LogError()","d":"LogWarnig()"},{"contentType":"多选题","content":"在.NET微服务中，.NET Core使用SQL Server数据库需要通过NuGet管理器安装哪些包（     ）?【选三项】","answer":"ACD","a":"Microsoft.EntityFrameworkCore.SqlServer包","b":"Microsoft.EntityFrameworkCore.Analyzers包","c":"Microsoft.EntityFrameworkCore.Design包","d":"Microsoft.EntityFrameworkCore.Tools包"},{"contentType":"单选题","content":"在.NET微服务中，下列关于EF6和EF Core说法错误的是（     ）","answer":"C","a":"两者在创建模式时都支持基本类的映射","b":"两者都支持Linq查询","c":"两者都支持批量更新功能","d":"两者都支持数据库的迁移"},{"contentType":"单选题","content":"在.NET微服务中，关于EF Core下列说法错误的是（     ）","answer":"D","a":"EF Core是轻量化、可扩展和跨平台版的Entity Framework","b":"Entity Framework Core (EF Core) 是适用于 .NET 的新式对象数据库映射器。 它支持 LINQ 查询、更改跟踪、更新和架构迁移","c":"EF Core 提供了不会在 EF6 中实现的新功能。 但是，并非所有 EF6 功能都已在 EF Core 中实现","d":"EF Core 在保有EF6所有功能前提下,提供了在 EF6 中不会实现的新功能"},{"contentType":"单选题","content":"在.NET微服务中，EF Core实体类中用注解的方式进行了相关映射，非空的注解为（     ）?","answer":"A","a":"Required","b":"Key","c":"Table","d":"DatabaseGenerated.Identity"},{"contentType":"单选题","content":"在.NET微服务中，EF Core下列（     ）命令是创建准备迁移的框架代码","answer":"A","a":"Add-Migration version","b":"remove-Migration","c":"Update-Database","d":"Script-Migration [version]"},{"contentType":"单选题","content":"在EF Core中使用数据上下文类，需要引用命名空间（     ）","answer":"B","a":"System.Text.Json.Serialization","b":"Microsoft.EntityFrameworkCore","c":"Microsoft.Extensions.Logging","d":"System.Linq"},{"contentType":"多选题","content":"在.NET微服务中，使用NuGet包管理命令来生成数据库和表，需要在程序包管理控制台输入以下哪两个命令（     ）?【选两项】","answer":"AC","a":"Add-Migration InitialCreate","b":"remove-Migration","c":"Update-Database","d":"Script-Migration [version]"},{"contentType":"单选题","content":"在.NET微服务中，EF Core使用NuGet反向生成实体模型命令的语法中各参数解释错误的是（     ）?","answer":"B","a":"-Context参数为可选项，没有该参数就按照数据库名称生成对象数据上下文名","b":"生成实体模型命令语法不需要注明数据提供程序名称","c":"null","d":"DataAnnotations参数为可选项，它表示生成实体模型类时，在类或属性上添加注解特性"},{"contentType":"单选题","content":"在.NET微服务中，关于EF Core使用Code First模式说法错误的是（     ）？","answer":"C","a":"模型类的字段名为ID会自动识别为主键","b":"模型类中的Icollection类型的字段会识别为导航属性并生成数据表的外键字段","c":"不可以使用MVC注解特性声明主键和约束","d":"连接字符串不局限于使用Windows登录"},{"contentType":"单选题","content":"在.NET微服务中，EF Core中下面哪个程序包提供EF的NuGet包管理器命令工具（     ）?","answer":"D","a":"Microsoft.EntityFrameworkCore.SqlServer包","b":"Microsoft.EntityFrameworkCore.Analyzers包","c":"Microsoft.EntityFrameworkCore.Design包","d":"Microsoft.EntityFrameworkCore.Tools包"},{"contentType":"单选题","content":"在.NET微服务中，EF Core中下面哪个程序包提供设计时使用到的EF共享库（     ）?","answer":"C","a":"Microsoft.EntityFrameworkCore.SqlServer包","b":"Microsoft.EntityFrameworkCore.Analyzers包","c":"Microsoft.EntityFrameworkCore.Design包","d":"Microsoft.EntityFrameworkCore.Tools包"},{"contentType":"单选题","content":"在.NET微服务中，EF Core中下面哪个程序包提供Sql Server数据库EF提供程序（     ）?","answer":"A","a":"Microsoft.EntityFrameworkCore.SqlServer包","b":"Microsoft.EntityFrameworkCore.Analyzers包","c":"Microsoft.EntityFrameworkCore.Design包","d":"Microsoft.EntityFrameworkCore.Tools包"},{"contentType":"多选题","content":"在.NET微服务中，gRPC是一款（     ）、（     ）、（     ） 的远程过程调用技术【选三项】","answer":"ACD","a":"开源","b":"微软提供","c":"语言中立","d":"平台中立"},{"contentType":"多选题","content":"在.NET微服务中，ASP.NET Core SignalR支持以下（     ）用于处理实时通信的传输方式【选三项】","answer":"ABC","a":"WebSocket传输方式","b":"基于服务器发送事件传输方式","c":"长轮询传输方式","d":"Server Sent Polling传输方式"},{"contentType":"多选题","content":"在ASP.NET Core中 ,下列属于Hub类Context属性的方法的是（     ）【选两项】","answer":"AB","a":"GetHttpContext","b":"Abort","c":"ConnectionAborted","d":"Client"},{"contentType":"多选题","content":"在ASP.NET Core中 ,Hub类Cilents属性是一个Client对象,其中包含服务器与客户端之间的通信的属性，下列属于Cilent对象的属性的是（     ）【选三项】","answer":"BCD","a":"Items","b":"ALL","c":"Caller","d":"Others"},{"contentType":"多选题","content":"在.NET微服务中，下列场景属于ASP.NET Core SignalR开发的应用程序能应用的场景的是（     ）【选三项】","answer":"BCD","a":"不需要从服务器进行高频率更新的应用","b":"仪表板和监控应用","c":"协作应用","d":"需要通知的应用程序"},{"contentType":"单选题","content":"在.NET微服务中，.NET Core提供了Grpc.AspNetCore、Grpc.Net.Client和（     ）三个gRPC软件包","answer":"C","a":"Grpc.Net.ClientCore","b":"Grpc.AspNetCore.Factory","c":"Grpc.Net.ClientFactory","d":"Grpc.AspNetCore.Client"},{"contentType":"单选题","content":"在.NET微服务中，下列对Protobuf协议文件的优点的描述错误的是（     ）","answer":"D","a":"足够简单","b":"更好的兼容性","c":"解析速度快，解析速度比XML快20--100倍","d":"序列化后体积很小，消息大小只需要XML大小的1/4—1/2"},{"contentType":"单选题","content":"在.NET微服务中，下面不是Protobuf协议文件组成的是（     ）","answer":"B","a":"声明Protobuf的版本","b":"定义端口","c":"定义请求消息","d":"定义服务，包含定义服务名、服务方法名、方法参数和返回值"},{"contentType":"单选题","content":"在.NET微服务中，下列关于gRPC特有的优势描述错误的是（     ）","answer":"C","a":"拥有现代化高性能轻量级RPC框架","b":"支持客户端和服务端双向流调用","c":"约定优先的API开发，默认使用Protobuf Language作为描述语言，允许与语言无关的实现","d":"使用HTTP/2进行传输"},{"contentType":"单选题","content":"在.NET微服务中，下列不是Protobuf协议文件字段修饰符的是（     ）","answer":"B","a":"required","b":"public","c":"optional","d":"repeated"},{"contentType":"单选题","content":"在.NET微服务中，对Protobuf、XML、JSON三种数据传输格式间的比较描述错误的是（     ）","answer":"A","a":"Protobuf的数据保存格式为文本","b":"XML的解析效率最慢","c":"JSON支持简单的数据结构","d":"Protobuf能保存数据的大小最小"},{"contentType":"单选题","content":"在.NET微服务中，下列创建gRPC服务的步骤正确的是：①配置新项目、②创建gRPC服务新项目、③添加服务引用、④创建Protobuf接口文件、⑤在Startup类中配置gRPC服务、⑥启动gRPC服务、⑦选择gRPC服务模板、⑧实现gRPC服务类（     ）","answer":"B","a":"①②⑦④③⑧⑤⑥","b":"②①⑦④③⑧⑤⑥","c":"②①⑦③④⑧⑤⑥","d":"①②⑦③④⑧⑤⑥"},{"contentType":"单选题","content":"在ASP.NET Core中,下列在ConfigureServices（     ）方法中添加gRPC服务支持正确的是（     ）","answer":"D","a":"public void ConfigureServices(IServiceCollection services){ services.AddGrup(); }","b":"public void ConfigureServices(IServiceCollection services){ services.AddGrups(); }","c":"public void ConfigureServices(IServiceCollection services){ services.AddGrpcs(); }","d":"public void ConfigureServices(IServiceCollection services){ services.AddGrpc(); }"},{"contentType":"单选题","content":"在.NET微服务中，创建gRPC客户端的步骤正确的是：①复制Protobuf文件、②创建gRPC客户端Web应用程序项目、③实现视图页面、④实现调用gRPC服务、⑤添加gRPC客户端引用、⑥运行gRPC客户端（     ）","answer":"B","a":"②⑤①④③⑥","b":"②①⑤④③⑥","c":"②⑤①③④⑥","d":"②⑤①③④⑥"},{"contentType":"单选题","content":"在.NET微服务中，gRPC不适用的应用场景是（     ）","answer":"D","a":"多语言混合开发","b":"高性能轻量级微服务","c":"点对点实时通信","d":"广播实时通信"},{"contentType":"单选题","content":"在.NET微服务中，下列对于SignalR的概述错误的是（     ）","answer":"B","a":"SignalR是一个开源库","b":"SignalR是ASP.NET Core所独有","c":"SignalR支持 “服务器推送”功能","d":"SignalR支持多种用于处理实时通信的传输方式"},{"contentType":"单选题","content":"在.NET微服务中，下面对ASP.NET Core SignalR的特性描述不正确的是（     ）","answer":"C","a":"ASP.NET Core SignalR是一个开源库，它简化了向应用程序添加实时web功能的过程","b":"ASP.NET Core SignalR会自动管理连接，并允许开发者向聊天室那样向所有连接的客户端同时发送消息，也可以向特定的客户发送消息","c":"ASP.NET Core SignalR不支持“服务器推送功能”","d":"ASP.NET Core SignalR可以将任何种类的“实时”web功能添加到ASP.NET Core应用程序中。"},{"contentType":"单选题","content":"在.NET微服务中，Protobuf的消息结构是通过（     ）语言进行定义和描述的","answer":"A","a":"Protobuf Buffer Language","b":"C#","c":"Protocol Buffers","d":"JSON"},{"contentType":"单选题","content":"在.NET微服务中，下列Protobuf协议文件字段数据类型与c#字段数据类型相对，错误的是（     ）","answer":"D","a":"string=string","b":"bool=bool","c":"bytes=byte[]","d":"int64=int"},{"contentType":"单选题","content":"在ASP.NET Core中 ,Hub类Cilents属性是一个Client对象,其中包含服务器与客户端之间的通信的属性，下列不属于Cilent对象的方法的是（     ）","answer":"D","a":"AllExcept","b":"Group","c":"Groups","d":"Abort"},{"contentType":"单选题","content":"在.NET微服务中，关于signalR支持的实时通信传输方式的优先级，正确的是（     ）","answer":"C","a":"Server Sent Events > WebSocket > Long Polling","b":"Long Polling > WebSocket >Server Sent Events","c":"WebSocket> Server Sent Events > Long Polling","d":"Server Sent Events >Long Polling> WebSocket"},{"contentType":"单选题","content":"在ASP.NET Core中 ,下列不属于Hub类的Context对象的属性的是（     ）","answer":"C","a":"UserIdentifier","b":"Items","c":"Users","d":"ConnectionAborted"},{"contentType":"单选题","content":"在.NET微服务中，下列属于gRPC适用的应用场景的是（     ）","answer":"B","a":"浏览器可访问的API","b":"多语言混合开发","c":"广播实时通信","d":"进程间通信"},{"contentType":"单选题","content":"在.NET微服务中，下面对Protobuf协议文件字段修饰符required和optional的描述不正确的是（     ）","answer":"C","a":"对于required的字段而言，初始值是必须要提供的，否则字段便是未初始化的","b":"对于required的字段而言，序列化的时候必须给予初始化，否则程序运行会出现异常","c":"对于optional的字段而言，未初始化不会自动赋予默认值。","d":"对于optional的字段而言，如果未进行初始化会自动赋值默认值，还可以指定默认值。"},{"contentType":"单选题","content":"在.NET微服务中，下列对于gRPC和SignalR的基本知识概述错误的是（     ）","answer":"D","a":"gRPC信道的地址是gRPC服务端启动时的地址","b":"SignalR并非ASP.NET Core所独有，它可以在基于.NET Framework4.0以上的ASP.NET Web应用程序中使用","c":"调用依赖于SignalR集线器保持活动状态的异步方法时，需要使用await关键字修饰","d":"SignalR集线器对象是暂时性的，所以需要将状态存储在Hub类的属性中"},{"contentType":"单选题","content":"在Redis中, 查看哈希表键中，指定的字段是否存在的命令是（     ）","answer":"D","a":"HSET key field value","b":"HGET key field","c":"HGETALL key","d":"HEXISTS key field"},{"contentType":"单选题","content":"在Redis中, 查找所有符合给定模式的键是（     ）","answer":"D","a":"DEL key","b":"DUMP key","c":"EXISTS key","d":"KEYS pattern"},{"contentType":"单选题","content":"在Redis中, 返回键所储存的字符串值的长度是（     ）","answer":"D","a":"SET key value","b":"GET key","c":"GETSET key value","d":"STRLEN key"},{"contentType":"单选题","content":"在Redis中, 获取存储在哈希表中指定字段的值是（     ）","answer":"B","a":"HSET key field value","b":"HGET key field","c":"HGETALL key","d":"HEXISTS key field"},{"contentType":"单选题","content":"在Redis中, 获取哈希表中所有值是（     ）","answer":"C","a":"HKEYS key","b":"HLEN key","c":"HVALS key","d":"HDEL key field1 [field2]"},{"contentType":"单选题","content":"在Redis中, 获取哈希表中字段的数量是（     ）","answer":"B","a":"HKEYS key","b":"HLEN key","c":"HVALS key","d":"HDEL key field1 [field2]"},{"contentType":"单选题","content":"在Redis中, 获取列表长度的命令是（     ）","answer":"C","a":"LPOP key","b":"RPOP key","c":"LLEN key","d":"LSET key index value"},{"contentType":"单选题","content":"在Redis中, 获取所有哈希表中的字段是（     ）","answer":"A","a":"HKEYS key","b":"HLEN key","c":"HVALS key","d":"HDEL key field1 [field2]"},{"contentType":"单选题","content":"在Redis中, 获取在哈希表中指定键的所有字段和值是（     ）","answer":"C","a":"HSET key field value","b":"HGET key field","c":"HGETALL key","d":"HEXISTS key field"},{"contentType":"单选题","content":"在Redis中, 获取指定键的值是（     ）","answer":"B","a":"SET key value","b":"GET key","c":"GETSET key value","d":"STRLEN key"},{"contentType":"单选题","content":"在Redis中, 检查指定的键是否存在是（     ）","answer":"C","a":"DEL key","b":"DUMP key","c":"EXISTS key","d":"KEYS pattern"},{"contentType":"单选题","content":"在Redis中, 将哈希表键中的字段的值设为value是（     ）","answer":"A","a":"HSET key field value","b":"HGET key field","c":"HGETALL key","d":"HEXISTS key field"},{"contentType":"单选题","content":"在Redis中, 将指定键设新值，并返回键的旧值是（     ）","answer":"C","a":"SET key value","b":"GET key","c":"GETSET key value","d":"STRLEN key"},{"contentType":"单选题","content":"在Redis中, 删除键的命令是（     ）","answer":"A","a":"DEL key","b":"DUMP key","c":"EXISTS key","d":"KEYS pattern"},{"contentType":"单选题","content":"在Redis中, 删除一个或多个哈希表字段是（     ）","answer":"D","a":"HKEYS key","b":"HLEN key","c":"HVALS key","d":"HDEL key field1 [field2]"},{"contentType":"单选题","content":"在Redis中, 设置指定键的值是（     ）","answer":"A","a":"SET key value","b":"GET key","c":"GETSET key value","d":"STRLEN key"},{"contentType":"单选题","content":"在Redis中, 通过索引设置列表元素的值的命令是（     ）","answer":"D","a":"LPOP key","b":"RPOP key","c":"LLEN key","d":"LSET key index value"},{"contentType":"单选题","content":"在Redis中, 序列化指定的键，并返回被序列化的值的命令是（     ）","answer":"B","a":"DEL key","b":"DUMP key","c":"EXISTS key","d":"KEYS pattern"},{"contentType":"单选题","content":"在Redis中, 移出并获取列表的第一个元素的命令是（     ）","answer":"A","a":"LPOP key","b":"RPOP key","c":"LLEN key","d":"LSET key index value"},{"contentType":"单选题","content":"在Redis中, 移除列表的最后一个元素的命令是（     ）","answer":"B","a":"LPOP key","b":"RPOP key","c":"LLEN key","d":"LSET key index value"},{"contentType":"多选题","content":"在.NET微服务中，Redis是一个使用ANSI C编写的键值对存储数据库，它有如下特征（     ）【选三项】","answer":"ABD","a":"开源的","b":"支持网络的","c":"基于磁盘的","d":"可选持久性"},{"contentType":"多选题","content":"在.NET微服务中，Redis包含丰富的数据类型,包括（     ）【选两项】","answer":"AB","a":"字符串","b":"哈希表","c":"数组","d":"整数"},{"contentType":"多选题","content":"在.NET微服务中，Redis采用哪些机制实现过期键的内存回收（     ）【选两项】","answer":"AB","a":"惰性删除","b":"定时任务删除","c":"随机删除","d":"延迟删除"},{"contentType":"多选题","content":"在.NET微服务中，Redis可用应用于哪些场景（     ）【选三项】","answer":"ACD","a":"缓存","b":"点对点实时通信","c":"简单消息队列","d":"会话（Session）共享"},{"contentType":"多选题","content":"在.NET微服务中，Redis中管理内存的方法有哪两种（     ）【选两项】","answer":"AB","a":"设置内存上限","b":"制订内存回收策略","c":"设置内存下限","d":"制订内存添加策略"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,按键值方式存储哈希表类型的方法是（     ）","answer":"A","a":"HashSet","b":"HashGet","c":"SortedSetRangeByRank","d":"SortedSetScore"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,按键值方式存储字符串类型的方法是（     ）","answer":"A","a":"StringSet","b":"StringGet","c":"SetAdd","d":"SetMembers"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库, 按键值方式获取哈希表类型的方法是（     ）","answer":"B","a":"HashSet","b":"HashGet","c":"SortedSetRangeByRank","d":"SortedSetScore"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,从列表头部获取数据的方法是（     ）","answer":"A","a":"ListLeftPop","b":"ListRightPop","c":"KeyDelete","d":"SetCombine"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,从列表尾部获取数据的方法是（     ）","answer":"B","a":"ListLeftPop","b":"ListRightPop","c":"KeyDelete","d":"SetCombine"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,从有序集合获取数据的方法是（     ）","answer":"D","a":"ListLeftPush","b":"ListRightPush","c":"SortedSetAdd","d":"SortedSetScan"},{"contentType":"单选题","content":"在ASP.NET Core Web应用程序中，提供四种方式存储Session的数据，其中对Custom方式描述正确的是（     ）","answer":"D","a":"Session存储在进程内，默认值。","b":"Session存储在独立的状态服务，即ASP.NET State Service中","c":"Session存储在SQL Server数据库中","d":"自定义保存方式，可以保存在MySql、MongoDb和Redis等"},{"contentType":"单选题","content":"在ASP.NET CORE中,StackExchange.Redis是第三方开发的高性能客户端，它不包含以下特点（     ）","answer":"A","a":"不支持Redis群","b":"完全双重编程模型使用","c":"可以方便的访问完整的Redis功能集","d":"高性能多路复用设计"},{"contentType":"单选题","content":"在.NET微服务中，一个Redis事务从开始到执行不会经历的阶段是（     ）","answer":"C","a":"开始事务","b":"命令入队","c":"初始化事务","d":"执行事务"},{"contentType":"单选题","content":"在.NET微服务中，Redis事务可以一次执行多个命令，并带有三个重要特征，其中不包括的特征是（     ）","answer":"B","a":"批量操作在发送到EXEC命令前被放入队列缓存","b":"收到EXEC命令后进入事务执行,命令执行失败，其余命令将不被执行","c":"收到EXEC命令后进入事务执行,命令执行失败，其余命令依然被执行","d":"在事务执行过程中，其他客户端提交的命令请求不会被插入到事务执行命令序列中"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,对指定范围的有序集合排名的方法是（     ）","answer":"C","a":"HashSet","b":"HashGet","c":"SortedSetRangeByRank","d":"SortedSetScore"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,根据键读取字符串类型的方法是（     ）","answer":"B","a":"StringSet","b":"StringGet","c":"SetAdd","d":"SetMembers"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,根据键删除数据的方法是（     ）","answer":"C","a":"ListLeftPop","b":"ListRightPop","c":"KeyDelete","d":"SetCombine"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,获取集合中的数据的方法是（     ）","answer":"D","a":"StringSet","b":"StringGet","c":"SetAdd","d":"SetMembers"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,获取指定键的有序集合成员评分的方法是（     ）","answer":"D","a":"HashSet","b":"HashGet","c":"SortedSetRangeByRank","d":"SortedSetScore"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,两个集合执行交集、并集和差集的方法是（     ）","answer":"D","a":"ListLeftPop","b":"ListRightPop","c":"KeyDelete","d":"SetCombine"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,向集合中保存数据的方法是（     ）","answer":"C","a":"StringSet","b":"StringGet","c":"SetAdd","d":"SetMembers"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,向列表头部插入数据的方法是（     ）","answer":"A","a":"ListLeftPush","b":"ListRightPush","c":"SortedSetAdd","d":"SortedSetScan"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,向列表尾部追加数据方法是（     ）","answer":"B","a":"ListLeftPush","b":"ListRightPush","c":"SortedSetAdd","d":"SortedSetScan"},{"contentType":"单选题","content":"在ASP.NET CORE中,使用StackExchange.Redis连接并操作的Redis数据库,向有序集合中添加数据的方法是（     ）","answer":"C","a":"ListLeftPush","b":"ListRightPush","c":"SortedSetAdd","d":"SortedSetScan"},{"contentType":"多选题","content":"在ASP.NET Core中,IDistributeCache接口主要就是封装了Redis的一些最基本的操作,它包括如下哪些方法（     ）【选三项】","answer":"ABC","a":"Set()","b":"Get()","c":"Refresh()","d":"Delete()"},{"contentType":"多选题","content":"在ASP.NET Core中, 如要在Redis中保存字符串数据，一般使用RedisCache类的哪些方法（     ）【选两项】","answer":"AB","a":"SetString()方法","b":"GetString()方法","c":"AddString()方法","d":"Delete()方法"},{"contentType":"多选题","content":"在Redis中,下列哪些是Redis事务的相关命令（     ）【选三项】","answer":"ABD","a":"discard","b":"exec","c":"begin","d":"unwatch"},{"contentType":"多选题","content":"在Redis中,下面不是创建事务的命令是（     ）【选三项】","answer":"BCD","a":"CreateTransaction","b":"AddCondition","c":"Execute","d":"Drop"},{"contentType":"多选题","content":"在ASP.NET Core Web应用程序中，提供以下（     ）方式存储Session的数据【选三项】","answer":"ABD","a":"InProc方式","b":"StateServer方式","c":"TextFile方式","d":"Custom方式"},{"contentType":"单选题","content":"在.NET微服务中，Docker容器在运行期间产生的数据是不会写在镜像里面的，重新用此镜像启动新的容器就会初始化镜像，会加一个全新的（     ）层来保存数据","answer":"D","a":"文件","b":"应用","c":"启动","d":"读写"},{"contentType":"单选题","content":"在.NET微服务中，Docker的数据持久化主要有两种方式分别是数据卷（data volume）和（     ）","answer":"A","a":"绑定挂载（bind mount）","b":"外部文件（external file）","c":"外挂硬盘（External hard drives）","d":"外挂光驱（External drives）"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令来查看包含的数据卷","answer":"C","a":"docker volume look","b":"docker ll","c":"docker volume ls","d":"docker volume show"},{"contentType":"单选题","content":"在.NET微服务中，如果有一些数据想在多个Docker容器间共享，或者想在一些临时性的Docker容器中使用该数据，那么最好的方案就是创建一个（     ）","answer":"B","a":"共享文件","b":"数据卷容器","c":"公共文件","d":"通用文件"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令只显示所有镜像ID","answer":"A","a":"docker images -q","b":"docker images -a","c":"docker images -o","d":"docker images"},{"contentType":"单选题","content":"在.NET微服务中，Docker将应用程序与该程序的依赖打包在一个文件里面运行这个文件，就会生成一个（     ）","answer":"B","a":"镜像","b":"虚拟容器","c":"界面","d":"服务"},{"contentType":"单选题","content":"在.NET微服务中，Docker使用（     ）架构","answer":"C","a":"MVC","b":"B/S","c":"C/S","d":"三层"},{"contentType":"单选题","content":"在.NET微服务中，Docker镜像（Image）就是一个（     ）的模板","answer":"D","a":"静态","b":"动态","c":"只写","d":"只读"},{"contentType":"单选题","content":"在.NET微服务中，Docker仓库（Repository）是集中存放（     ）文件的场所","answer":"A","a":"镜像","b":"容器","c":"配置","d":"应用"},{"contentType":"单选题","content":"在.NET微服务中，Docker利用（     ）来运行应用","answer":"D","a":"镜像","b":"web","c":"exe","d":"容器"},{"contentType":"单选题","content":"在.NET微服务中，Docker容器是从（     ）创建的运行实例","answer":"B","a":"文件","b":"镜像","c":"仓库","d":"应用程序"},{"contentType":"单选题","content":"在.NET微服务中，Docker官方建议将Docker安装到（     ）操作系统中","answer":"C","a":"Windows XP","b":"Windows 7","c":"Linux","d":"Windows 10"},{"contentType":"单选题","content":"在Windows 7中可使用第三方工具（     ）来安装Docker","answer":"A","a":"Docker Toolbox","b":"yum","c":"Docker Desktop for Windows","d":"pip"},{"contentType":"单选题","content":"在Docker中, 镜像和容器的关系，就像是面向对象程序设计中类和实例一样，镜像是静态的定义，容器是镜像（     ）的实体","answer":"B","a":"编译时","b":"运行时","c":"new时","d":"调试时"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令用于创建一个新的Docker容器","answer":"D","a":"new","b":"run","c":"pause","d":"create"},{"contentType":"单选题","content":"在.NET微服务中，对Docker命令：docker create --name myapp microsoft/dotnet-samples 解读正确的是（     ）","answer":"C","a":"创建名为myapp的镜像","b":"创建名为myapp的静态文件","c":"创建名为myapp的容器","d":"创建名为myapp的动态文件"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令将创建并运行一个新的容器","answer":"B","a":"pause","b":"run","c":"create","d":"new"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令可以查看运行中或运行过的容器信息","answer":"C","a":"show","b":"system","c":"ps","d":"ls"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令暂停一个或多个容器","answer":"D","a":"kill","b":"fill","c":"stop","d":"pause"},{"contentType":"单选题","content":"在.NET微服务中，使用Docker的（     ）命令搜索镜像","answer":"A","a":"search","b":"find","c":"grep","d":"look"}]